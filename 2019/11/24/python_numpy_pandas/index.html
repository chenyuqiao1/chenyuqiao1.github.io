<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bio_info_bridge.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="python_numpy &amp;pandas学习这部分内容和R语言的逻辑非常相似。所有，还是很方便理解，主要是因为我最近看到了complexheatmap画突变的热图，需要这个模块，我就简单的学习一下。 最为重要的科学计算模块，使用python进行数据分析必备，这两个主要用在machine leaning ，神经网络，比python自带的字典快，用C语言写的，使用了的矩阵计算。 学习参考视频">
<meta property="og:type" content="article">
<meta property="og:title" content="python_numpy_pandas">
<meta property="og:url" content="http://bio_info_bridge.cn/2019/11/24/python_numpy_pandas/index.html">
<meta property="og:site_name" content="Bio_info_bridge">
<meta property="og:description" content="python_numpy &amp;pandas学习这部分内容和R语言的逻辑非常相似。所有，还是很方便理解，主要是因为我最近看到了complexheatmap画突变的热图，需要这个模块，我就简单的学习一下。 最为重要的科学计算模块，使用python进行数据分析必备，这两个主要用在machine leaning ，神经网络，比python自带的字典快，用C语言写的，使用了的矩阵计算。 学习参考视频">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://bio_info_bridge.cn/2019/11/24/python_numpy_pandas/3-8-1.png">
<meta property="og:image" content="http://bio_info_bridge.cn/2019/11/24/python_numpy_pandas/3-8-2.png">
<meta property="og:image" content="http://bio_info_bridge.cn/2019/11/24/python_numpy_pandas/3-8-3.png">
<meta property="og:image" content="https://morvanzhou.github.io/static/results/np-pd/4-1-2.png">
<meta property="og:image" content="https://morvanzhou.github.io/static/results/np-pd/4-1-3.png">
<meta property="og:image" content="https://morvanzhou.github.io/static/results/np-pd/4-1-4.png">
<meta property="og:image" content="https://morvanzhou.github.io/static/results/np-pd/4-1-5.png">
<meta property="article:published_time" content="2019-11-23T16:00:00.000Z">
<meta property="article:modified_time" content="2020-05-17T13:54:55.916Z">
<meta property="article:author" content="yuqiao chen">
<meta property="article:tag" content="python语言学习">
<meta property="article:tag" content="numpy">
<meta property="article:tag" content="pandas">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://bio_info_bridge.cn/2019/11/24/python_numpy_pandas/3-8-1.png">

<link rel="canonical" href="http://bio_info_bridge.cn/2019/11/24/python_numpy_pandas/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>python_numpy_pandas | Bio_info_bridge</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Bio_info_bridge</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://bio_info_bridge.cn/2019/11/24/python_numpy_pandas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuqiao chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bio_info_bridge">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          python_numpy_pandas
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-24 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-24T00:00:00+08:00">2019-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-17 21:54:55" itemprop="dateModified" datetime="2020-05-17T21:54:55+08:00">2020-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="python-numpy-amp-pandas学习"><a href="#python-numpy-amp-pandas学习" class="headerlink" title="python_numpy &amp;pandas学习"></a>python_numpy &amp;pandas学习</h1><p><strong>这部分内容和R语言的逻辑非常相似。所有，还是很方便理解，主要是因为我最近看到了complexheatmap画突变的热图，需要这个模块，我就简单的学习一下。</strong></p>
<p>最为重要的科学计算模块，使用python进行数据分析必备，这两个主要用在machine leaning ，神经网络，比python自带的字典快，用C语言写的，使用了的矩阵计算。</p>
<p><a href="https://morvanzhou.github.io/tutorials/" target="_blank" rel="noopener">学习参考视频</a></p>
<a id="more"></a>



<h3 id="numpy的学习"><a href="#numpy的学习" class="headerlink" title="numpy的学习"></a>numpy的学习</h3><h4 id="一：安装numpy-and-pandas"><a href="#一：安装numpy-and-pandas" class="headerlink" title="一：安装numpy and pandas"></a>一：安装numpy and pandas</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install numpy</span><br><span class="line">sudo pip3 install pandas</span><br></pre></td></tr></table></figure>







<h4 id="二：-简单的矩阵"><a href="#二：-简单的矩阵" class="headerlink" title="二： 简单的矩阵"></a>二： 简单的矩阵</h4><blockquote>
<p>关于简单的矩阵学习</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 简单矩阵例子</span></span><br><span class="line">array = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">print(array)</span><br><span class="line">print(<span class="string">'number od dim:'</span>,array.ndim)</span><br><span class="line">print(<span class="string">'shape:'</span>,array.shape)</span><br><span class="line">print(<span class="string">'size:'</span>,array.size)</span><br></pre></td></tr></table></figure>



<h4 id="三：继续创建array"><a href="#三：继续创建array" class="headerlink" title="三：继续创建array"></a>三：继续创建array</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 简单矩阵例子</span></span><br><span class="line">a= np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],dtype=np.int) <span class="comment"># arrayde type</span></span><br><span class="line">a= np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],dtype=np.float)</span><br><span class="line">print(a.dtype)</span><br><span class="line"></span><br><span class="line">array = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">b=np.zeros((<span class="number">3</span>,<span class="number">4</span>)) <span class="comment"># 全部为0的3行4列的矩阵</span></span><br><span class="line">c=np.ones((<span class="number">3</span>,<span class="number">4</span>),dtype=np.int16) <span class="comment"># 全部为1的3行4列的矩阵</span></span><br><span class="line">d=np.empty((<span class="number">4</span>,<span class="number">3</span>)) <span class="comment"># 为空的矩阵</span></span><br><span class="line">a=np.arange(<span class="number">10</span>,<span class="number">20</span>,<span class="number">2</span>) <span class="comment"># 10,12,14,16,18</span></span><br><span class="line">e=np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">a=np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>) <span class="comment">#生成线段1-10 分为5段</span></span><br><span class="line">a=np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>).reshape((<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<h4 id="四：numpy基础运算形式"><a href="#四：numpy基础运算形式" class="headerlink" title="四：numpy基础运算形式"></a>四：numpy基础运算形式</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a=np.array([10,20,30,40])   # array([10, 20, 30, 40])</span><br><span class="line">b=np.arange(4)              # array([0, 1, 2, 3])</span><br></pre></td></tr></table></figure>



<p>上述代码中的 <code>a</code> 和 <code>b</code> 是两个属性为 array 也就是矩阵的变量，而且二者都是1行4列的矩阵， 其中b矩阵中的元素分别是从0到3。 如果我们想要求两个矩阵之间的减法，你可以尝试着输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c&#x3D;a-b  # array([10, 19, 28, 37])</span><br></pre></td></tr></table></figure>

<p>通过执行上述脚本，将会得到对应元素相减的结果，即<code>[10,19,28,37]</code>。 同理，矩阵对应元素的相加和相乘也可以用类似的方式表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c=a+b   <span class="comment"># array([10, 21, 32, 43])</span></span><br><span class="line">c=a*b   <span class="comment"># array([  0,  20,  60, 120])</span></span><br></pre></td></tr></table></figure>

<p>有所不同的是，在Numpy中，想要求出矩阵中各个元素的乘方需要依赖双星符号 <code>**</code>，以二次方举例，即：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=b**<span class="number">2</span>  <span class="comment"># array([0, 1, 4, 9])</span></span><br></pre></td></tr></table></figure>

<p>另外，Numpy中具有很多的数学函数工具，比如三角函数等，当我们需要对矩阵中每一项元素进行函数运算时，可以很简便的调用它们（以<code>sin</code>函数为例）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c=<span class="number">10</span>*np.sin(a)  </span><br><span class="line"><span class="comment"># array([-5.44021111,  9.12945251, -9.88031624,  7.4511316 ])</span></span><br></pre></td></tr></table></figure>

<p>除了函数应用外，在脚本中对<code>print</code>函数进行一些修改可以进行逻辑判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(b&lt;<span class="number">3</span>)  </span><br><span class="line"><span class="comment"># array([ True,  True,  True, False], dtype=bool)</span></span><br></pre></td></tr></table></figure>

<p>此时由于进行逻辑判断，返回的是一个bool类型的矩阵，即对满足要求的返回<code>True</code>，不满足的返回<code>False</code>。上述程序执行后得到的结果是<code>[True True True False]</code>。 需要注意的是，如果想要执行是否相等的判断， 依然需要输入 <code>==</code> 而不是 <code>=</code> 来完成相应的逻辑判断。</p>
<p>上述运算均是建立在一维矩阵，即只有一行的矩阵上面的计算，如果我们想要对多行多维度的矩阵进行操作，需要对开始的脚本进行一些修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">b=np.arange(<span class="number">4</span>).reshape((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># array([[1, 1],</span></span><br><span class="line"><span class="comment">#       [0, 1]])</span></span><br><span class="line"></span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># array([[0, 1],</span></span><br><span class="line"><span class="comment">#       [2, 3]])</span></span><br></pre></td></tr></table></figure>



<p>此时构造出来的矩阵<code>a</code>和<code>b</code>便是2行2列的，其中 <code>reshape</code> 操作是对矩阵的形状进行重构， 其重构的形状便是括号中给出的数字。 稍显不同的是，Numpy中的矩阵乘法分为两种， 其一是前文中的对应元素相乘，其二是标准的矩阵乘法运算，即对应行乘对应列得到相应元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c_dot &#x3D; np.dot(a,b)</span><br><span class="line"># array([[2, 4],</span><br><span class="line">#       [2, 3]])</span><br></pre></td></tr></table></figure>

<p>除此之外还有另外的一种关于<code>dot</code>的表示方法，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c_dot_2 &#x3D; a.dot(b)</span><br><span class="line"># array([[2, 4],</span><br><span class="line">#       [2, 3]])</span><br></pre></td></tr></table></figure>

<p>下面我们将重新定义一个脚本, 来看看关于 <code>sum()</code>, <code>min()</code>, <code>max()</code>的使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a&#x3D;np.random.random((2,4))</span><br><span class="line">print(a)</span><br><span class="line"># array([[ 0.94692159,  0.20821798,  0.35339414,  0.2805278 ],</span><br><span class="line">#       [ 0.04836775,  0.04023552,  0.44091941,  0.21665268]])</span><br></pre></td></tr></table></figure>

<p>因为是随机生成数字, 所以你的结果可能会不一样. 在第二行中对<code>a</code>的操作是令<code>a</code>中生成一个2行4列的矩阵，且每一元素均是来自从0到1的随机数。 在这个随机生成的矩阵中，我们可以对元素进行求和以及寻找极值的操作，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.sum(a)   # 4.4043622002745959</span><br><span class="line">np.min(a)   # 0.23651223533671784</span><br><span class="line">np.max(a)   # 0.90438450240606416</span><br></pre></td></tr></table></figure>

<p>对应的便是对矩阵中所有元素进行求和，寻找最小值，寻找最大值的操作。 可以通过<code>print()</code>函数对相应值进行打印检验。</p>
<p>如果你需要对行或者列进行查找运算，就需要在上述代码中为 axis 进行赋值。 当axis的值为0的时候，将会以列作为查找单元， 当axis的值为1的时候，将会以行作为查找单元。</p>
<p>为了更加清晰，在刚才的例子中我们继续进行查找：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"a ="</span>,a)</span><br><span class="line"><span class="comment"># a = [[ 0.23651224  0.41900661  0.84869417  0.46456022]</span></span><br><span class="line"><span class="comment"># [ 0.60771087  0.9043845   0.36603285  0.55746074]]</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"sum ="</span>,np.sum(a,axis=<span class="number">1</span>)) <span class="comment"># 1 代表行</span></span><br><span class="line"><span class="comment"># sum = [ 1.96877324  2.43558896]</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"min ="</span>,np.min(a,axis=<span class="number">0</span>)) <span class="comment"># 0 代表列</span></span><br><span class="line"><span class="comment"># min = [ 0.23651224  0.41900661  0.36603285  0.46456022]</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"max ="</span>,np.max(a,axis=<span class="number">1</span>))</span><br><span class="line"><span class="comment"># max = [ 0.84869417  0.9043845 ]</span></span><br></pre></td></tr></table></figure>



<h4 id="五：Numpy-基础运算2"><a href="#五：Numpy-基础运算2" class="headerlink" title="五：Numpy 基础运算2"></a>五：Numpy 基础运算2</h4><p>学习资料:</p>
<ul>
<li><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html" target="_blank" rel="noopener">Numpy官方英文教材</a></li>
</ul>
<p>通过上一节的学习，我们可以了解到一部分矩阵中元素的计算和查找操作。然而在日常使用中，对应元素的索引也是非常重要的。依然，让我们先从一个脚本开始 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">A &#x3D; np.arange(2,14).reshape((3,4)) </span><br><span class="line"></span><br><span class="line"># array([[ 2, 3, 4, 5]</span><br><span class="line">#        [ 6, 7, 8, 9]</span><br><span class="line">#        [10,11,12,13]])</span><br><span class="line">         </span><br><span class="line">print(np.argmin(A))    # 0 元素索引</span><br><span class="line">print(np.argmax(A))    # 11 元素索引</span><br></pre></td></tr></table></figure>

<h4 id="六：numpy-的几种基本运算"><a href="#六：numpy-的几种基本运算" class="headerlink" title="六：numpy 的几种基本运算"></a>六：numpy 的几种基本运算</h4><p>其中的 <code>argmin()</code> 和 <code>argmax()</code> 两个函数分别对应着求矩阵中最小元素和最大元素的索引。相应的，在矩阵的12个元素中，最小值即2，对应索引0，最大值为13，对应索引为11。</p>
<p>如果需要计算统计中的均值，可以利用下面的方式，将整个矩阵的均值求出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(np.mean(A))        # 7.5</span><br><span class="line">print(np.average(A))     # 7.5</span><br></pre></td></tr></table></figure>

<p>仿照着前一节中<code>dot()</code> 的使用法则，<code>mean()</code>函数还有另外一种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(A.mean())          # 7.5</span><br></pre></td></tr></table></figure>

<p>同样的，我们可以写出求解中位数的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(A.median())       # 7.5</span><br></pre></td></tr></table></figure>

<p>另外，和matlab中的<code>cumsum()</code>累加函数类似，Numpy中也具有<code>cumsum()</code>函数，其用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(np.cumsum(A)) </span><br><span class="line"></span><br><span class="line"># [2 5 9 14 20 27 35 44 54 65 77 90]</span><br></pre></td></tr></table></figure>

<p>在<code>cumsum()</code>函数中：生成的每一项矩阵元素均是从原矩阵首项累加到对应项的元素之和。比如元素9，在<code>cumsum()</code>生成的矩阵中序号为3，即原矩阵中2，3，4三个元素的和。</p>
<p>相应的有累差运算函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(np.diff(A))    </span><br><span class="line"></span><br><span class="line"># [[1 1 1]</span><br><span class="line">#  [1 1 1]</span><br><span class="line">#  [1 1 1]]</span><br></pre></td></tr></table></figure>

<p>该函数计算的便是每一行中后一项与前一项之差。故一个3行4列矩阵通过函数计算得到的矩阵便是3行3列的矩阵。</p>
<p>下面我们介绍一下<code>nonzero()</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(np.nonzero(A))    </span><br><span class="line"></span><br><span class="line"># (array([0,0,0,0,1,1,1,1,2,2,2,2]),array([0,1,2,3,0,1,2,3,0,1,2,3]))</span><br></pre></td></tr></table></figure>



<p>这个函数将所有非零元素的行与列坐标分割开，重构成两个分别关于行和列的矩阵。</p>
<p>同样的，我们可以对所有元素进行仿照列表一样的排序操作，但这里的排序函数仍然仅针对每一行进行从小到大排序操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">A &#x3D; np.arange(14,2, -1).reshape((3,4)) </span><br><span class="line"></span><br><span class="line"># array([[14, 13, 12, 11],</span><br><span class="line">#       [10,  9,  8,  7],</span><br><span class="line">#       [ 6,  5,  4,  3]])</span><br><span class="line"></span><br><span class="line">print(np.sort(A))    </span><br><span class="line"></span><br><span class="line"># array([[11,12,13,14]</span><br><span class="line">#        [ 7, 8, 9,10]</span><br><span class="line">#        [ 3, 4, 5, 6]])</span><br></pre></td></tr></table></figure>

<p>矩阵的转置有两种表示方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(np.transpose(A))    </span><br><span class="line">print(A.T)</span><br><span class="line"></span><br><span class="line"># array([[14,10, 6]</span><br><span class="line">#        [13, 9, 5]</span><br><span class="line">#        [12, 8, 4]</span><br><span class="line">#        [11, 7, 3]])</span><br><span class="line"># array([[14,10, 6]</span><br><span class="line">#        [13, 9, 5]</span><br><span class="line">#        [12, 8, 4]</span><br><span class="line">#        [11, 7, 3]])</span><br></pre></td></tr></table></figure>

<p>特别的，在Numpy中具有<code>clip()</code>函数，例子如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(A)</span><br><span class="line"><span class="comment"># array([[14,13,12,11]</span></span><br><span class="line"><span class="comment">#        [10, 9, 8, 7]</span></span><br><span class="line"><span class="comment">#        [ 6, 5, 4, 3]])</span></span><br><span class="line"></span><br><span class="line">print(np.clip(A,<span class="number">5</span>,<span class="number">9</span>))    </span><br><span class="line"><span class="comment"># array([[ 9, 9, 9, 9]</span></span><br><span class="line"><span class="comment">#        [ 9, 9, 8, 7]</span></span><br><span class="line"><span class="comment">#        [ 6, 5, 5, 5]])</span></span><br><span class="line"><span class="comment"># 直接剪裁，大于9都等于9，小于5都等于5</span></span><br></pre></td></tr></table></figure>

<p>这个函数的格式是<code>clip(Array,Array_min,Array_max)</code>，顾名思义，<code>Array</code>指的是将要被执行用的矩阵，而后面的最小值最大值则用于让函数判断矩阵中元素是否有比最小值小的或者比最大值大的元素，并将这些指定的元素转换为最小值或者最大值。</p>
<p>实际上每一个Numpy中大多数函数均具有很多变量可以操作，你可以指定行、列甚至某一范围中的元素。更多具体的使用细节请记得查阅<a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html" target="_blank" rel="noopener">Numpy官方英文教材</a>。</p>
<h4 id="七：Numpy-索引"><a href="#七：Numpy-索引" class="headerlink" title="七：Numpy 索引"></a>七：Numpy 索引</h4><p><strong>一维索引</strong></p>
<p>我们都知道，在元素列表或者数组中，我们可以用如同<code>a[2]</code>一样的表示方法，同样的，在Numpy中也有相对应的表示方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">A &#x3D; np.arange(3,15)</span><br><span class="line"></span><br><span class="line"># array([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])</span><br><span class="line">         </span><br><span class="line">print(A[3])    # 6</span><br></pre></td></tr></table></figure>

<p>让我们将矩阵转换为二维的，此时进行同样的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; np.arange(3,15).reshape((3,4))</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">array([[ 3,  4,  5,  6]</span><br><span class="line">       [ 7,  8,  9, 10]</span><br><span class="line">       [11, 12, 13, 14]])</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">         </span><br><span class="line">print(A[2])         </span><br><span class="line"># [11 12 13 14]</span><br></pre></td></tr></table></figure>

<p>实际上这时的<code>A[2]</code>对应的就是矩阵<code>A</code>中第三行(从0开始算第一行)的所有元素。</p>
<p><strong>二维索引</strong> </p>
<p>如果你想要表示具体的单个元素，可以仿照上述的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(A[1][1])      # 8</span><br></pre></td></tr></table></figure>

<p>此时对应的元素即<code>A[1][1]</code>，在<code>A</code>中即横纵坐标都为1，第二行第二列的元素，即8（因为计数从0开始）。同样的还有其他的表示方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(A[1, 1])      # 8</span><br></pre></td></tr></table></figure>

<p>在Python的 list 中，我们可以利用<code>:</code>对一定范围内的元素进行切片操作，在Numpy中我们依然可以给出相应的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(A[1, 1:3])    # [8 9]</span><br></pre></td></tr></table></figure>

<p>这一表示形式即针对第二行中第2到第4列元素进行切片输出（不包含第4列）。 此时我们适当的利用for函数进行打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for row in A:</span><br><span class="line">    print(row)</span><br><span class="line">&quot;&quot;&quot;    </span><br><span class="line">[ 3,  4,  5, 6]</span><br><span class="line">[ 7,  8,  9, 10]</span><br><span class="line">[11, 12, 13, 14]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>此时它会逐行进行打印操作。如果想进行逐列打印，就需要稍稍变化一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对列进行迭代</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> A.T:</span><br><span class="line">    print(row)</span><br><span class="line"><span class="string">"""  </span></span><br><span class="line"><span class="string">[ 3,  7,  11]</span></span><br><span class="line"><span class="string">[ 4,  8,  12]</span></span><br><span class="line"><span class="string">[ 5,  9,  13]</span></span><br><span class="line"><span class="string">[ 6, 10,  14]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>上述表示方法即对A进行转置，再将得到的矩阵逐行输出即可得到原矩阵的逐列输出。</p>
<p>最后依然说一些关于迭代输出的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">A &#x3D; np.arange(3,15).reshape((3,4))</span><br><span class="line">         </span><br><span class="line">print(A.flatten())   </span><br><span class="line"># array([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])</span><br><span class="line"></span><br><span class="line">for item in A.flat:</span><br><span class="line">    print(item)</span><br><span class="line">    </span><br><span class="line"># 3</span><br><span class="line"># 4</span><br><span class="line">……</span><br><span class="line"># 14</span><br></pre></td></tr></table></figure>

<p>这一脚本中的<code>flatten</code>是一个展开性质的函数，将多维的矩阵进行展开成1行的数列。而<code>flat</code>是一个迭代器，本身是一个<code>object</code>属性。</p>
<h4 id="八：Numpy-array-合并"><a href="#八：Numpy-array-合并" class="headerlink" title="八：Numpy array 合并"></a>八：Numpy array 合并</h4><h5 id="np-vstack"><a href="#np-vstack" class="headerlink" title="np.vstack()"></a>np.vstack()</h5><p>对于一个<code>array</code>的合并，我们可以想到按行、按列等多种方式进行合并。首先先看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">A &#x3D; np.array([1,1,1])</span><br><span class="line">B &#x3D; np.array([2,2,2])</span><br><span class="line">         </span><br><span class="line">print(np.vstack((A,B)))    # vertical stack</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[[1,1,1]</span><br><span class="line"> [2,2,2]]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><code>vertical stack</code>本身属于一种上下合并，即对括号中的两个整体进行对应操作。此时我们对组合而成的矩阵进行属性探究：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C &#x3D; np.vstack((A,B))      </span><br><span class="line">print(A.shape,C.shape)</span><br><span class="line"></span><br><span class="line"># (3,) (2,3)</span><br></pre></td></tr></table></figure>

<h5 id="np-hstack"><a href="#np-hstack" class="headerlink" title="np.hstack()"></a>np.hstack()</h5><p>利用<code>shape</code>函数可以让我们很容易地知道<code>A</code>和<code>C</code>的属性，从打印出的结果来看，<code>A</code>仅仅是一个拥有3项元素的数组（数列），而合并后得到的<code>C</code>是一个2行3列的矩阵。</p>
<p>介绍完了上下合并，我们来说说左右合并：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D &#x3D; np.hstack((A,B))       # horizontal stack</span><br><span class="line"></span><br><span class="line">print(D)</span><br><span class="line"># [1,1,1,2,2,2]</span><br><span class="line"></span><br><span class="line">print(A.shape,D.shape)</span><br><span class="line"># (3,) (6,)</span><br></pre></td></tr></table></figure>

<p>通过打印出的结果可以看出：<code>D</code>本身来源于<code>A</code>，<code>B</code>两个数列的左右合并，而且新生成的<code>D</code>本身也是一个含有6项元素的序列。</p>
<h5 id="np-newaxis"><a href="#np-newaxis" class="headerlink" title="np.newaxis()"></a>np.newaxis()</h5><p>说完了<code>array</code>的合并，我们稍稍提及一下前一节中转置操作，<strong>如果面对如同前文所述的<code>A</code>序列， 转置操作便很有可能无法对其进行转置（因为<code>A</code>并不是矩阵的属性）**</strong>也就是无法进行A.T**，此时就需要我们借助其他的函数操作进行转置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">print(A[np.newaxis,:])</span><br><span class="line"><span class="comment"># [[1 1 1]]</span></span><br><span class="line"></span><br><span class="line">print(A[np.newaxis,:].shape)</span><br><span class="line"><span class="comment"># (1,3)</span></span><br><span class="line"></span><br><span class="line">print(A[:,np.newaxis])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[1]</span></span><br><span class="line"><span class="string">[1]</span></span><br><span class="line"><span class="string">[1]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(A[:,np.newaxis].shape) <span class="comment"># : 表示所有，从0到无穷的意思，np.newaxis表示增加一个维度</span></span><br><span class="line"><span class="comment"># (3,1)</span></span><br></pre></td></tr></table></figure>

<p>此时我们便将具有3个元素的<code>array</code>转换为了1行3列以及3行1列的矩阵了。</p>
<p>结合着上面的知识，我们把它综合起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">A &#x3D; np.array([1,1,1])[:,np.newaxis]</span><br><span class="line">B &#x3D; np.array([2,2,2])[:,np.newaxis]</span><br><span class="line">         </span><br><span class="line">C &#x3D; np.vstack((A,B))   # vertical stack</span><br><span class="line">D &#x3D; np.hstack((A,B))   # horizontal stack</span><br><span class="line"></span><br><span class="line">print(D)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[[1 2]</span><br><span class="line">[1 2]</span><br><span class="line">[1 2]]</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">print(A.shape,D.shape)</span><br><span class="line"># (3,1) (3,2)</span><br></pre></td></tr></table></figure>



<h5 id="np-concatenate"><a href="#np-concatenate" class="headerlink" title="np.concatenate()"></a>np.concatenate()</h5><p>当你的合并操作需要针对多个矩阵或序列时，借助<code>concatenate</code>函数可能会让你使用起来比前述的函数更加方便：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">C = np.concatenate((A,B,B,A),axis=<span class="number">0</span>) <span class="comment"># concatenate: 连结</span></span><br><span class="line"></span><br><span class="line">print(C)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [1]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">D = np.concatenate((A,B,B,A),axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(D)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1, 2, 2, 1],</span></span><br><span class="line"><span class="string">       [1, 2, 2, 1],</span></span><br><span class="line"><span class="string">       [1, 2, 2, 1]])</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p><code>axis</code>参数很好的控制了矩阵的纵向或是横向打印，相比较<code>vstack</code>和<code>hstack</code>函数显得更加方便。</p>
<h4 id="九：Numpy-array-分割"><a href="#九：Numpy-array-分割" class="headerlink" title="九：Numpy array 分割"></a>九：Numpy array 分割</h4><h5 id="创建数据"><a href="#创建数据" class="headerlink" title="创建数据"></a>创建数据</h5><p>首先 <code>import</code> 模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br></pre></td></tr></table></figure>

<p>建立3行4列的Array</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; np.arange(12).reshape((3, 4))</span><br><span class="line">print(A)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">array([[ 0,  1,  2,  3],</span><br><span class="line">    [ 4,  5,  6,  7],</span><br><span class="line">    [ 8,  9, 10, 11]])</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h5 id="纵向分割"><a href="#纵向分割" class="headerlink" title="纵向分割"></a>纵向分割</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(np.split(A, 2, axis&#x3D;1))</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[array([[0, 1],</span><br><span class="line">        [4, 5],</span><br><span class="line">        [8, 9]]), array([[ 2,  3],</span><br><span class="line">        [ 6,  7],</span><br><span class="line">        [10, 11]])]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h5 id="横向分割"><a href="#横向分割" class="headerlink" title="横向分割"></a>横向分割</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(np.split(A, 3, axis&#x3D;0))</span><br><span class="line"></span><br><span class="line"># [array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</span><br></pre></td></tr></table></figure>

<h5 id="错误的分割"><a href="#错误的分割" class="headerlink" title="错误的分割"></a>错误的分割</h5><p>范例的Array只有4列，只能等量对分，因此输入以上程序代码后Python就会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(np.split(A, 3, axis&#x3D;1))</span><br><span class="line"></span><br><span class="line"># ValueError: array split does not result in an equal division</span><br></pre></td></tr></table></figure>

<p>为了解决这种情况, 我们会有下面这种方式.</p>
<h5 id="不等量的分割"><a href="#不等量的分割" class="headerlink" title="不等量的分割"></a>不等量的分割</h5><p>在机器学习时经常会需要将数据做不等量的分割，因此解决办法为<code>np.array_split()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(np.array_split(A, 3, axis&#x3D;1))</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[array([[0, 1],</span><br><span class="line">        [4, 5],</span><br><span class="line">        [8, 9]]), array([[ 2],</span><br><span class="line">        [ 6],</span><br><span class="line">        [10]]), array([[ 3],</span><br><span class="line">        [ 7],</span><br><span class="line">        [11]])]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>成功将Array不等量分割!</p>
<h5 id="其他的分割方式"><a href="#其他的分割方式" class="headerlink" title="其他的分割方式"></a>其他的分割方式</h5><p>在Numpy里还有<code>np.vsplit()</code>与横<code>np.hsplit()</code>方式可用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">print(np.vsplit(A, 3)) #等于 print(np.split(A, 3, axis&#x3D;0))</span><br><span class="line"></span><br><span class="line"># [array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(np.hsplit(A, 2)) #等于 print(np.split(A, 2, axis&#x3D;1))</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[array([[0, 1],</span><br><span class="line">       [4, 5],</span><br><span class="line">       [8, 9]]), array([[ 2,  3],</span><br><span class="line">        [ 6,  7],</span><br><span class="line">        [10, 11]])]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>



<h4 id="十：Numpy-copy-amp-deep-copy"><a href="#十：Numpy-copy-amp-deep-copy" class="headerlink" title="十：Numpy copy &amp; deep copy"></a>十：Numpy copy &amp; deep copy</h4><h5 id="的赋值方式会带有关联性"><a href="#的赋值方式会带有关联性" class="headerlink" title="= 的赋值方式会带有关联性"></a>= 的赋值方式会带有关联性</h5><p>首先 <code>import numpy</code> 并建立变量, 给变量赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a &#x3D; np.arange(4)</span><br><span class="line"># array([0, 1, 2, 3])</span><br><span class="line"></span><br><span class="line">b &#x3D; a</span><br><span class="line">c &#x3D; a</span><br><span class="line">d &#x3D; b</span><br></pre></td></tr></table></figure>

<p>改变<code>a</code>的第一个值，<code>b</code>、<code>c</code>、<code>d</code>的第一个值也会同时改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[0] &#x3D; 11</span><br><span class="line">print(a)</span><br><span class="line"># array([11,  1,  2,  3])</span><br></pre></td></tr></table></figure>

<p>确认<code>b</code>、<code>c</code>、<code>d</code>是否与<code>a</code>相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b is a  # True</span><br><span class="line">c is a  # True</span><br><span class="line">d is a  # True</span><br></pre></td></tr></table></figure>

<p>同样更改<code>d</code>的值，<code>a</code>、<code>b</code>、<code>c</code>也会改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d[1:3] &#x3D; [22, 33]   # array([11, 22, 33,  3])</span><br><span class="line">print(a)            # array([11, 22, 33,  3])</span><br><span class="line">print(b)            # array([11, 22, 33,  3])</span><br><span class="line">print(c)            # array([11, 22, 33,  3])</span><br></pre></td></tr></table></figure>

<h5 id="copy-的赋值方式没有关联性-¶"><a href="#copy-的赋值方式没有关联性-¶" class="headerlink" title="copy() 的赋值方式没有关联性 ¶"></a>copy() 的赋值方式没有关联性 <a href="https://morvanzhou.github.io/tutorials/data-manipulation/np-pd/2-8-np-copy/#copy()-的赋值方式没有关联性" target="_blank" rel="noopener">¶</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b &#x3D; a.copy()    # deep copy</span><br><span class="line">print(b)        # array([11, 22, 33,  3])</span><br><span class="line">a[3] &#x3D; 44</span><br><span class="line">print(a)        # array([11, 22, 33, 44])</span><br><span class="line">print(b)        # array([11, 22, 33,  3])</span><br></pre></td></tr></table></figure>

<p>此时<code>a</code>与<code>b</code>已经没有关联。</p>
<h3 id="Panda的学习"><a href="#Panda的学习" class="headerlink" title="Panda的学习"></a>Panda的学习</h3><h4 id="一：Pandas-基本介绍"><a href="#一：Pandas-基本介绍" class="headerlink" title="一：Pandas 基本介绍"></a>一：Pandas 基本介绍</h4><p>学习资料:</p>
<ul>
<li><a href="https://github.com/MorvanZhou/tutorials/blob/master/numpy%26pandas/11_pandas_intro.py" target="_blank" rel="noopener">相关代码</a></li>
</ul>
<h5 id="Numpy-和-Pandas-有什么不同"><a href="#Numpy-和-Pandas-有什么不同" class="headerlink" title="Numpy 和 Pandas 有什么不同"></a>Numpy 和 Pandas 有什么不同</h5><p>如果用 python 的列表和字典来作比较, 那么可以说 Numpy 是列表形式的，没有数值标签，而 Pandas 就是字典形式。Pandas是基于Numpy构建的，让Numpy为中心的应用变得更加简单。</p>
<p>要使用pandas，首先需要了解他主要两个数据结构：Series和DataFrame。</p>
<h5 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">s &#x3D; pd.Series([1,3,6,np.nan,44,1])</span><br><span class="line"></span><br><span class="line">print(s)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">0     1.0</span><br><span class="line">1     3.0</span><br><span class="line">2     6.0</span><br><span class="line">3     NaN</span><br><span class="line">4    44.0</span><br><span class="line">5     1.0</span><br><span class="line">dtype: float64</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><code>Series</code>的字符串表现形式为：索引在左边，值在右边。由于我们没有为数据指定索引。于是会自动创建一个0到N-1（N为长度）的整数型索引。</p>
<h5 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dates &#x3D; pd.date_range(&#39;20160101&#39;,periods&#x3D;6)</span><br><span class="line">df &#x3D; pd.DataFrame(np.random.randn(6,4),index&#x3D;dates,columns&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])</span><br><span class="line"></span><br><span class="line">print(df)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">                   a         b         c         d</span><br><span class="line">2016-01-01 -0.253065 -2.071051 -0.640515  0.613663</span><br><span class="line">2016-01-02 -1.147178  1.532470  0.989255 -0.499761</span><br><span class="line">2016-01-03  1.221656 -2.390171  1.862914  0.778070</span><br><span class="line">2016-01-04  1.473877 -0.046419  0.610046  0.204672</span><br><span class="line">2016-01-05 -1.584752 -0.700592  1.487264 -1.778293</span><br><span class="line">2016-01-06  0.633675 -1.414157 -0.277066 -0.442545</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><code>DataFrame</code>是一个表格型的数据结构，它包含有一组有序的列，每列可以是不同的值类型（数值，字符串，布尔值等）。<code>DataFrame</code>既有行索引也有列索引， 它可以被看做由<code>Series</code>组成的大字典。</p>
<p>我们可以根据每一个不同的索引来挑选数据, 比如挑选 <code>b</code> 的元素:</p>
<h5 id="DataFrame-的一些简单运用"><a href="#DataFrame-的一些简单运用" class="headerlink" title="DataFrame 的一些简单运用"></a>DataFrame 的一些简单运用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(df[&#39;b&#39;])</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">2016-01-01   -2.071051</span><br><span class="line">2016-01-02    1.532470</span><br><span class="line">2016-01-03   -2.390171</span><br><span class="line">2016-01-04   -0.046419</span><br><span class="line">2016-01-05   -0.700592</span><br><span class="line">2016-01-06   -1.414157</span><br><span class="line">Freq: D, Name: b, dtype: float64</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>我们在创建一组没有给定行标签和列标签的数据 <code>df1</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df1 &#x3D; pd.DataFrame(np.arange(12).reshape((3,4)))</span><br><span class="line">print(df1)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">   0  1   2   3</span><br><span class="line">0  0  1   2   3</span><br><span class="line">1  4  5   6   7</span><br><span class="line">2  8  9  10  11</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>这样,他就会采取默认的从0开始 index. 还有一种生成 <code>df</code> 的方法, 如下 <code>df2</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">df2 &#x3D; pd.DataFrame(&#123;&#39;A&#39; : 1.,</span><br><span class="line">                    &#39;B&#39; : pd.Timestamp(&#39;20130102&#39;),</span><br><span class="line">                    &#39;C&#39; : pd.Series(1,index&#x3D;list(range(4)),dtype&#x3D;&#39;float32&#39;),</span><br><span class="line">                    &#39;D&#39; : np.array([3] * 4,dtype&#x3D;&#39;int32&#39;),</span><br><span class="line">                    &#39;E&#39; : pd.Categorical([&quot;test&quot;,&quot;train&quot;,&quot;test&quot;,&quot;train&quot;]),</span><br><span class="line">                    &#39;F&#39; : &#39;foo&#39;&#125;)</span><br><span class="line">                    </span><br><span class="line">print(df2)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">     A          B    C  D      E    F</span><br><span class="line">0  1.0 2013-01-02  1.0  3   test  foo</span><br><span class="line">1  1.0 2013-01-02  1.0  3  train  foo</span><br><span class="line">2  1.0 2013-01-02  1.0  3   test  foo</span><br><span class="line">3  1.0 2013-01-02  1.0  3  train  foo</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>这种方法能对每一列的数据进行特殊对待. 如果想要查看数据中的类型, 我们可以用 <code>dtype</code> 这个属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(df2.dtypes)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">df2.dtypes</span><br><span class="line">A           float64</span><br><span class="line">B    datetime64[ns]</span><br><span class="line">C           float32</span><br><span class="line">D             int32</span><br><span class="line">E          category</span><br><span class="line">F            object</span><br><span class="line">dtype: object</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>如果想看对列的序号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(df2.index)</span><br><span class="line"></span><br><span class="line"># Int64Index([0, 1, 2, 3], dtype&#x3D;&#39;int64&#39;)</span><br></pre></td></tr></table></figure>

<p>同样, 每种数据的名称也能看到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(df2.columns)</span><br><span class="line"></span><br><span class="line"># Index([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;], dtype&#x3D;&#39;object&#39;)</span><br></pre></td></tr></table></figure>

<p>如果只想看所有<code>df2</code>的值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(df2.values)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">array([[1.0, Timestamp(&#39;2013-01-02 00:00:00&#39;), 1.0, 3, &#39;test&#39;, &#39;foo&#39;],</span><br><span class="line">       [1.0, Timestamp(&#39;2013-01-02 00:00:00&#39;), 1.0, 3, &#39;train&#39;, &#39;foo&#39;],</span><br><span class="line">       [1.0, Timestamp(&#39;2013-01-02 00:00:00&#39;), 1.0, 3, &#39;test&#39;, &#39;foo&#39;],</span><br><span class="line">       [1.0, Timestamp(&#39;2013-01-02 00:00:00&#39;), 1.0, 3, &#39;train&#39;, &#39;foo&#39;]], dtype&#x3D;object)</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>想知道数据的总结, 可以用 <code>describe()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df2.describe()</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">         A    C    D</span><br><span class="line">count  4.0  4.0  4.0</span><br><span class="line">mean   1.0  1.0  3.0</span><br><span class="line">std    0.0  0.0  0.0</span><br><span class="line">min    1.0  1.0  3.0</span><br><span class="line">25%    1.0  1.0  3.0</span><br><span class="line">50%    1.0  1.0  3.0</span><br><span class="line">75%    1.0  1.0  3.0</span><br><span class="line">max    1.0  1.0  3.0</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>如果想翻转数据, <code>transpose</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">print(df2.T)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;                   </span><br><span class="line">0                    1                    2  \</span><br><span class="line">A                    1                    1                    1   </span><br><span class="line">B  2013-01-02 00:00:00  2013-01-02 00:00:00  2013-01-02 00:00:00   </span><br><span class="line">C                    1                    1                    1   </span><br><span class="line">D                    3                    3                    3   </span><br><span class="line">E                 test                train                 test   </span><br><span class="line">F                  foo                  foo                  foo   </span><br><span class="line"></span><br><span class="line">                     3  </span><br><span class="line">A                    1  </span><br><span class="line">B  2013-01-02 00:00:00  </span><br><span class="line">C                    1  </span><br><span class="line">D                    3  </span><br><span class="line">E                train  </span><br><span class="line">F                  foo  </span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>如果想对数据的 <code>index</code> 进行排序并输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(df2.sort_index(axis&#x3D;1, ascending&#x3D;False))</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">     F      E  D    C          B    A</span><br><span class="line">0  foo   test  3  1.0 2013-01-02  1.0</span><br><span class="line">1  foo  train  3  1.0 2013-01-02  1.0</span><br><span class="line">2  foo   test  3  1.0 2013-01-02  1.0</span><br><span class="line">3  foo  train  3  1.0 2013-01-02  1.0</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>如果是对数据 值 排序输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(df2.sort_values(by&#x3D;&#39;B&#39;))</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">     A          B    C  D      E    F</span><br><span class="line">0  1.0 2013-01-02  1.0  3   test  foo</span><br><span class="line">1  1.0 2013-01-02  1.0  3  train  foo</span><br><span class="line">2  1.0 2013-01-02  1.0  3   test  foo</span><br><span class="line">3  1.0 2013-01-02  1.0  3  train  foo</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>






<h4 id="二：Pandas-选择数据"><a href="#二：Pandas-选择数据" class="headerlink" title="二：Pandas 选择数据"></a>二：Pandas 选择数据</h4><p>学习资料:</p>
<ul>
<li><a href="https://github.com/MorvanZhou/tutorials/blob/master/numpy%26pandas/12_selection.py" target="_blank" rel="noopener">相关代码</a></li>
</ul>
<p>我们建立了一个 6X4 的矩阵数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dates &#x3D; pd.date_range(&#39;20130101&#39;, periods&#x3D;6)</span><br><span class="line">df &#x3D; pd.DataFrame(np.arange(24).reshape((6,4)),index&#x3D;dates, columns&#x3D;[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;])</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">             A   B   C   D</span><br><span class="line">2013-01-01   0   1   2   3</span><br><span class="line">2013-01-02   4   5   6   7</span><br><span class="line">2013-01-03   8   9  10  11</span><br><span class="line">2013-01-04  12  13  14  15</span><br><span class="line">2013-01-05  16  17  18  19</span><br><span class="line">2013-01-06  20  21  22  23</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h5 id="简单的筛选"><a href="#简单的筛选" class="headerlink" title="简单的筛选"></a>简单的筛选</h5><p>如果我们想选取<code>DataFrame</code>中的数据，下面描述了两种途径, 他们都能达到同一个目的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(df[&#39;A&#39;])</span><br><span class="line">print(df.A)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">2013-01-01     0</span><br><span class="line">2013-01-02     4</span><br><span class="line">2013-01-03     8</span><br><span class="line">2013-01-04    12</span><br><span class="line">2013-01-05    16</span><br><span class="line">2013-01-06    20</span><br><span class="line">Freq: D, Name: A, dtype: int64</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>让选择跨越多行或多列:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">print(df[0:3])</span><br><span class="line"> </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">            A  B   C   D</span><br><span class="line">2013-01-01  0  1   2   3</span><br><span class="line">2013-01-02  4  5   6   7</span><br><span class="line">2013-01-03  8  9  10  11</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">print(df[&#39;20130102&#39;:&#39;20130104&#39;])</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">A   B   C   D</span><br><span class="line">2013-01-02   4   5   6   7</span><br><span class="line">2013-01-03   8   9  10  11</span><br><span class="line">2013-01-04  12  13  14  15</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>如果<code>df[3:3]</code>将会是一个空对象。后者选择<code>20130102</code>到<code>20130104</code>标签之间的数据，并且包括这两个标签。</p>
<h5 id="根据标签-loc"><a href="#根据标签-loc" class="headerlink" title="根据标签 loc"></a>根据标签 loc</h5><p>同样我们可以使用标签来选择数据 <code>loc</code>, 本例子主要通过标签名字选择某一行数据， 或者通过选择某行或者所有行（<code>:</code>代表所有行）然后选其中某一列或几列数据。:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">print(df.loc[&#39;20130102&#39;])</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">A    4</span><br><span class="line">B    5</span><br><span class="line">C    6</span><br><span class="line">D    7</span><br><span class="line">Name: 2013-01-02 00:00:00, dtype: int64</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">print(df.loc[:,[&#39;A&#39;,&#39;B&#39;]])  # 保留所有行，帅选列</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">             A   B</span><br><span class="line">2013-01-01   0   1</span><br><span class="line">2013-01-02   4   5</span><br><span class="line">2013-01-03   8   9</span><br><span class="line">2013-01-04  12  13</span><br><span class="line">2013-01-05  16  17</span><br><span class="line">2013-01-06  20  21</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">print(df.loc[&#39;20130102&#39;,[&#39;A&#39;,&#39;B&#39;]])</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">A    4</span><br><span class="line">B    5</span><br><span class="line">Name: 2013-01-02 00:00:00, dtype: int64</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h5 id="根据序列-iloc-–position"><a href="#根据序列-iloc-–position" class="headerlink" title="根据序列 iloc –position"></a>根据序列 iloc –position</h5><p>另外我们可以采用位置进行选择 <code>iloc</code>, 在这里我们可以通过位置选择在不同情况下所需要的数据例如选某一个，连续选或者跨行选等操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">print(df.iloc[3,1])</span><br><span class="line"># 13</span><br><span class="line"></span><br><span class="line">print(df.iloc[3:5,1:3])</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">             B   C</span><br><span class="line">2013-01-04  13  14</span><br><span class="line">2013-01-05  17  18</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">print(df.iloc[[1,3,5],1:3])</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">             B   C</span><br><span class="line">2013-01-02   5   6</span><br><span class="line">2013-01-04  13  14</span><br><span class="line">2013-01-06  21  22</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>在这里我们可以通过位置选择在不同情况下所需要的数据, 例如选某一个，连续选或者跨行选等操作。</p>
<h5 id="根据混合的这两种-ix"><a href="#根据混合的这两种-ix" class="headerlink" title="根据混合的这两种 ix"></a>根据混合的这两种 ix</h5><p>当然我们可以采用混合选择 <code>ix</code>, 其中选择’A’和’C’的两列，并选择前三行的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(df.ix[:3,[&#39;A&#39;,&#39;C&#39;]])</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">            A   C</span><br><span class="line">2013-01-01  0   2</span><br><span class="line">2013-01-02  4   6</span><br><span class="line">2013-01-03  8  10</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h5 id="通过判断的筛选"><a href="#通过判断的筛选" class="headerlink" title="通过判断的筛选"></a>通过判断的筛选</h5><p>最后我们可以采用判断指令 (Boolean indexing) 进行选择. 我们可以约束某项条件然后选择出当前所有数据.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(df[df.A&gt;8])</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">             A   B   C   D</span><br><span class="line">2013-01-04  12  13  14  15</span><br><span class="line">2013-01-05  16  17  18  19</span><br><span class="line">2013-01-06  20  21  22  23</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>下节我们将会讲到Pandas中如何设置值。</p>
<h4 id="Pandas-设置值"><a href="#Pandas-设置值" class="headerlink" title="Pandas 设置值"></a>Pandas 设置值</h4><p>学习资料:</p>
<ul>
<li><a href="https://github.com/MorvanZhou/tutorials/blob/master/numpy%26pandas/13_set_value.py" target="_blank" rel="noopener">相关代码</a></li>
</ul>
<h5 id="创建数据-1"><a href="#创建数据-1" class="headerlink" title="创建数据"></a>创建数据</h5><p>我们可以根据自己的需求, 用 pandas 进行更改数据里面的值, 或者加上一些空的,或者有数值的列.</p>
<p>首先建立了一个 6X4 的矩阵数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dates &#x3D; pd.date_range(&#39;20130101&#39;, periods&#x3D;6)</span><br><span class="line">df &#x3D; pd.DataFrame(np.arange(24).reshape((6,4)),index&#x3D;dates, columns&#x3D;[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;])</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">             A   B   C   D</span><br><span class="line">2013-01-01   0   1   2   3</span><br><span class="line">2013-01-02   4   5   6   7</span><br><span class="line">2013-01-03   8   9  10  11</span><br><span class="line">2013-01-04  12  13  14  15</span><br><span class="line">2013-01-05  16  17  18  19</span><br><span class="line">2013-01-06  20  21  22  23</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h5 id="根据位置设置-loc-和-iloc"><a href="#根据位置设置-loc-和-iloc" class="headerlink" title="根据位置设置 loc 和 iloc"></a>根据位置设置 loc 和 iloc</h5><p>我们可以利用索引或者标签确定需要修改值的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[2,2] &#x3D; 1111</span><br><span class="line">df.loc[&#39;20130101&#39;,&#39;B&#39;] &#x3D; 2222</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">             A     B     C   D</span><br><span class="line">2013-01-01   0  2222     2   3</span><br><span class="line">2013-01-02   4     5     6   7</span><br><span class="line">2013-01-03   8     9  1111  11</span><br><span class="line">2013-01-04  12    13    14  15</span><br><span class="line">2013-01-05  16    17    18  19</span><br><span class="line">2013-01-06  20    21    22  23</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h5 id="根据条件设置"><a href="#根据条件设置" class="headerlink" title="根据条件设置"></a>根据条件设置</h5><p>如果现在的判断条件是这样, 我们想要更改<code>B</code>中的数, 而更改的位置是取决于 <code>A</code> 的. 对于<code>A</code>大于4的位置. 更改<code>B</code>在相应位置上的数为0.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df.B[df.A&gt;4] &#x3D; 0</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">                A     B     C   D</span><br><span class="line">2013-01-01   0  2222     2   3</span><br><span class="line">2013-01-02   4     5     6   7</span><br><span class="line">2013-01-03   8     0  1111  11</span><br><span class="line">2013-01-04  12     0    14  15</span><br><span class="line">2013-01-05  16     0    18  19</span><br><span class="line">2013-01-06  20     0    22  23 </span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>



<h5 id="按行或列设置"><a href="#按行或列设置" class="headerlink" title="按行或列设置"></a>按行或列设置</h5><p>如果对整列做批处理, 加上一列 ‘F’, 并将 <code>F</code> 列全改为 <code>NaN</code>, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df[&#39;F&#39;] &#x3D; np.nan</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">             A     B     C   D   F</span><br><span class="line">2013-01-01   0  2222     2   3 NaN</span><br><span class="line">2013-01-02   4     5     6   7 NaN</span><br><span class="line">2013-01-03   8     0  1111  11 NaN</span><br><span class="line">2013-01-04  12     0    14  15 NaN</span><br><span class="line">2013-01-05  16     0    18  19 NaN</span><br><span class="line">2013-01-06  20     0    22  23 NaN</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h5 id="添加数据-¶"><a href="#添加数据-¶" class="headerlink" title="添加数据 ¶"></a>添加数据 <a href="https://morvanzhou.github.io/tutorials/data-manipulation/np-pd/3-3-pd-assign/#添加数据" target="_blank" rel="noopener">¶</a></h5><p>用上面的方法也可以加上 <code>Series</code> 序列（但是长度必须对齐）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df[&#39;E&#39;] &#x3D; pd.Series([1,2,3,4,5,6], index&#x3D;pd.date_range(&#39;20130101&#39;,periods&#x3D;6)) </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">             A     B     C   D   F  E</span><br><span class="line">2013-01-01   0  2222     2   3 NaN  1</span><br><span class="line">2013-01-02   4     5     6   7 NaN  2</span><br><span class="line">2013-01-03   8     0  1111  11 NaN  3</span><br><span class="line">2013-01-04  12     0    14  15 NaN  4</span><br><span class="line">2013-01-05  16     0    18  19 NaN  5</span><br><span class="line">2013-01-06  20     0    22  23 NaN  6</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>这样我们大概学会了如何对<code>DataFrame</code>中在自己想要的地方赋值或者增加数据。 下次课会将pandas如何处理丢失数据的过程。</p>
<h4 id="四：Pandas-处理丢失数据"><a href="#四：Pandas-处理丢失数据" class="headerlink" title="四：Pandas 处理丢失数据"></a>四：Pandas 处理丢失数据</h4><p>学习资料:</p>
<ul>
<li><a href="https://github.com/MorvanZhou/tutorials/blob/master/numpy%26pandas/14_nan.py" target="_blank" rel="noopener">相关代码</a></li>
</ul>
<h5 id="创建含-NaN-的矩阵"><a href="#创建含-NaN-的矩阵" class="headerlink" title="创建含 NaN 的矩阵"></a>创建含 NaN 的矩阵</h5><p>有时候我们导入或处理数据, 会产生一些空的或者是 <code>NaN</code> 数据,如何删除或者是填补这些 <code>NaN</code> 数据就是我们今天所要提到的内容.</p>
<p>建立了一个6X4的矩阵数据并且把两个位置置为空.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dates &#x3D; pd.date_range(&#39;20130101&#39;, periods&#x3D;6)</span><br><span class="line">df &#x3D; pd.DataFrame(np.arange(24).reshape((6,4)),index&#x3D;dates, columns&#x3D;[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;])</span><br><span class="line">df.iloc[0,1] &#x3D; np.nan</span><br><span class="line">df.iloc[1,2] &#x3D; np.nan</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">             A     B     C   D</span><br><span class="line">2013-01-01   0   NaN   2.0   3</span><br><span class="line">2013-01-02   4   5.0   NaN   7</span><br><span class="line">2013-01-03   8   9.0  10.0  11</span><br><span class="line">2013-01-04  12  13.0  14.0  15</span><br><span class="line">2013-01-05  16  17.0  18.0  19</span><br><span class="line">2013-01-06  20  21.0  22.0  23</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>



<h5 id="pd-dropna"><a href="#pd-dropna" class="headerlink" title="pd.dropna()"></a>pd.dropna()</h5><p>如果想直接去掉有 <code>NaN</code> 的行或列, 可以使用 <code>dropna</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df.dropna(</span><br><span class="line">    axis&#x3D;0,     # 0: 对行进行操作; 1: 对列进行操作</span><br><span class="line">    how&#x3D;&#39;any&#39;   # &#39;any&#39;: 只要存在 NaN 就 drop 掉; &#39;all&#39;: 必须全部是 NaN 才 drop </span><br><span class="line">    ) </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">             A     B     C   D</span><br><span class="line">2013-01-03   8   9.0  10.0  11</span><br><span class="line">2013-01-04  12  13.0  14.0  15</span><br><span class="line">2013-01-05  16  17.0  18.0  19</span><br><span class="line">2013-01-06  20  21.0  22.0  23</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h5 id="pd-fillna"><a href="#pd-fillna" class="headerlink" title="pd.fillna()"></a>pd.fillna()</h5><p>如果是将 <code>NaN</code> 的值用其他值代替, 比如代替成 <code>0</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(value&#x3D;0)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">             A     B     C   D</span><br><span class="line">2013-01-01   0   0.0   2.0   3</span><br><span class="line">2013-01-02   4   5.0   0.0   7</span><br><span class="line">2013-01-03   8   9.0  10.0  11</span><br><span class="line">2013-01-04  12  13.0  14.0  15</span><br><span class="line">2013-01-05  16  17.0  18.0  19</span><br><span class="line">2013-01-06  20  21.0  22.0  23</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h5 id="pd-isnull"><a href="#pd-isnull" class="headerlink" title="pd.isnull()"></a>pd.isnull()</h5><p>判断是否有缺失数据 <code>NaN</code>, 为 <code>True</code> 表示缺失数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df.isnull() </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">                A      B      C      D</span><br><span class="line">2013-01-01  False   True  False  False</span><br><span class="line">2013-01-02  False  False   True  False</span><br><span class="line">2013-01-03  False  False  False  False</span><br><span class="line">2013-01-04  False  False  False  False</span><br><span class="line">2013-01-05  False  False  False  False</span><br><span class="line">2013-01-06  False  False  False  False</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>检测在数据中是否存在 <code>NaN</code>, 如果存在就返回 <code>True</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.any(df.isnull()) &#x3D;&#x3D; True  </span><br><span class="line"># True</span><br></pre></td></tr></table></figure>

<p>下次课会将pandas如何导入导出数据的过程。</p>
<h4 id="五：Pandas-导入导出"><a href="#五：Pandas-导入导出" class="headerlink" title="五：Pandas 导入导出"></a>五：Pandas 导入导出</h4><p>学习资料:</p>
<ul>
<li><a href="https://github.com/MorvanZhou/tutorials/tree/master/numpy%26pandas/15_read_to" target="_blank" rel="noopener">相关代码</a></li>
</ul>
<h5 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h5><p><code>pandas</code>可以读取与存取的资料格式有很多种，像<code>csv</code>、<code>excel</code>、<code>json</code>、<code>html</code>与<code>pickle</code>等…， 详细请看<a href="http://pandas.pydata.org/pandas-docs/stable/io.html" target="_blank" rel="noopener">官方说明文件</a></p>
<h5 id="读取csv"><a href="#读取csv" class="headerlink" title="读取csv"></a>读取csv</h5><p>示范档案下载 - <a href="https://github.com/MorvanZhou/tutorials/blob/master/numpy%26pandas/15_read_to/student.csv" target="_blank" rel="noopener">student.csv</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd #加载模块</span><br><span class="line"></span><br><span class="line">#读取csv</span><br><span class="line">data &#x3D; pd.read_csv(&#39;student.csv&#39;)</span><br><span class="line"></span><br><span class="line">#打印出data</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>



<h5 id="将资料存取成pickle"><a href="#将资料存取成pickle" class="headerlink" title="将资料存取成pickle"></a>将资料存取成pickle</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.to_pickle(&#39;student.pickle&#39;)</span><br></pre></td></tr></table></figure>





<h4 id="六：Pandas-合并-concat—concatenating"><a href="#六：Pandas-合并-concat—concatenating" class="headerlink" title="六：Pandas 合并 concat—concatenating"></a>六：Pandas 合并 concat—concatenating</h4><p>学习资料:</p>
<ul>
<li><a href="https://github.com/MorvanZhou/tutorials/blob/master/numpy%26pandas/16_concat.py" target="_blank" rel="noopener">相关代码</a></li>
</ul>
<h5 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h5><p><code>pandas</code>处理多组数据的时候往往会要用到数据的合并处理,使用 <code>concat</code>是一种基本的合并方式.而且<code>concat</code>中有很多参数可以调整,合并成你想要的数据形式.</p>
<h5 id="axis-合并方向"><a href="#axis-合并方向" class="headerlink" title="axis (合并方向)"></a>axis (合并方向)</h5><p><code>axis=0</code>是预设值，因此未设定任何参数时，函数默认<code>axis=0</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">#定义资料集</span><br><span class="line">df1 &#x3D; pd.DataFrame(np.ones((3,4))*0, columns&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])</span><br><span class="line">df2 &#x3D; pd.DataFrame(np.ones((3,4))*1, columns&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])</span><br><span class="line">df3 &#x3D; pd.DataFrame(np.ones((3,4))*2, columns&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])</span><br><span class="line"></span><br><span class="line">#concat纵向合并</span><br><span class="line">res &#x3D; pd.concat([df1, df2, df3], axis&#x3D;0)</span><br><span class="line"></span><br><span class="line">#打印结果</span><br><span class="line">print(res)</span><br><span class="line">#     a    b    c    d</span><br><span class="line"># 0  0.0  0.0  0.0  0.0</span><br><span class="line"># 1  0.0  0.0  0.0  0.0</span><br><span class="line"># 2  0.0  0.0  0.0  0.0</span><br><span class="line"># 0  1.0  1.0  1.0  1.0</span><br><span class="line"># 1  1.0  1.0  1.0  1.0</span><br><span class="line"># 2  1.0  1.0  1.0  1.0</span><br><span class="line"># 0  2.0  2.0  2.0  2.0</span><br><span class="line"># 1  2.0  2.0  2.0  2.0</span><br><span class="line"># 2  2.0  2.0  2.0  2.0</span><br></pre></td></tr></table></figure>

<p>仔细观察会发现结果的<code>index</code>是0, 1, 2, 0, 1, 2, 0, 1, 2，若要将<code>index</code>重置，请看<strong>例子二</strong>。</p>
<h5 id="ignore-index-重置-index"><a href="#ignore-index-重置-index" class="headerlink" title="ignore_index (重置 index)"></a>ignore_index (重置 index)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#承上一个例子，并将index_ignore设定为True</span><br><span class="line">res &#x3D; pd.concat([df1, df2, df3], axis&#x3D;0, ignore_index&#x3D;True)</span><br><span class="line"></span><br><span class="line">#打印结果</span><br><span class="line">print(res)</span><br><span class="line">#     a    b    c    d</span><br><span class="line"># 0  0.0  0.0  0.0  0.0</span><br><span class="line"># 1  0.0  0.0  0.0  0.0</span><br><span class="line"># 2  0.0  0.0  0.0  0.0</span><br><span class="line"># 3  1.0  1.0  1.0  1.0</span><br><span class="line"># 4  1.0  1.0  1.0  1.0</span><br><span class="line"># 5  1.0  1.0  1.0  1.0</span><br><span class="line"># 6  2.0  2.0  2.0  2.0</span><br><span class="line"># 7  2.0  2.0  2.0  2.0</span><br><span class="line"># 8  2.0  2.0  2.0  2.0</span><br></pre></td></tr></table></figure>

<p>结果的<code>index</code>变0, 1, 2, 3, 4, 5, 6, 7, 8。</p>
<h5 id="join-合并方式"><a href="#join-合并方式" class="headerlink" title="join (合并方式)"></a>join (合并方式)</h5><p><code>join=&#39;outer&#39;</code>为预设值，因此未设定任何参数时，函数默认<code>join=&#39;outer&#39;</code>。此方式是依照<code>column</code>来做纵向合并，有相同的<code>column</code>上下合并在一起，其他独自的<code>column</code>个自成列，原本没有值的位置皆以<code>NaN</code>填充。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">#定义资料集</span><br><span class="line">df1 &#x3D; pd.DataFrame(np.ones((3,4))*0, columns&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;], index&#x3D;[1,2,3])</span><br><span class="line">df2 &#x3D; pd.DataFrame(np.ones((3,4))*1, columns&#x3D;[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;], index&#x3D;[2,3,4])</span><br><span class="line"></span><br><span class="line">#纵向&quot;外&quot;合并df1与df2</span><br><span class="line">res &#x3D; pd.concat([df1, df2], axis&#x3D;0, join&#x3D;&#39;outer&#39;)</span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line">#     a    b    c    d    e</span><br><span class="line"># 1  0.0  0.0  0.0  0.0  NaN</span><br><span class="line"># 2  0.0  0.0  0.0  0.0  NaN</span><br><span class="line"># 3  0.0  0.0  0.0  0.0  NaN</span><br><span class="line"># 2  NaN  1.0  1.0  1.0  1.0</span><br><span class="line"># 3  NaN  1.0  1.0  1.0  1.0</span><br><span class="line"># 4  NaN  1.0  1.0  1.0  1.0</span><br></pre></td></tr></table></figure>

<p>原理同上个例子的说明，但只有相同的<code>column</code>合并在一起，其他的会被抛弃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#承上一个例子</span><br><span class="line"></span><br><span class="line">#纵向&quot;内&quot;合并df1与df2</span><br><span class="line">res &#x3D; pd.concat([df1, df2], axis&#x3D;0, join&#x3D;&#39;inner&#39;)</span><br><span class="line"></span><br><span class="line">#打印结果</span><br><span class="line">print(res)</span><br><span class="line">#     b    c    d</span><br><span class="line"># 1  0.0  0.0  0.0</span><br><span class="line"># 2  0.0  0.0  0.0</span><br><span class="line"># 3  0.0  0.0  0.0</span><br><span class="line"># 2  1.0  1.0  1.0</span><br><span class="line"># 3  1.0  1.0  1.0</span><br><span class="line"># 4  1.0  1.0  1.0</span><br><span class="line"></span><br><span class="line">#重置index并打印结果</span><br><span class="line">res &#x3D; pd.concat([df1, df2], axis&#x3D;0, join&#x3D;&#39;inner&#39;, ignore_index&#x3D;True)</span><br><span class="line">print(res)</span><br><span class="line">#     b    c    d</span><br><span class="line"># 0  0.0  0.0  0.0</span><br><span class="line"># 1  0.0  0.0  0.0</span><br><span class="line"># 2  0.0  0.0  0.0</span><br><span class="line"># 3  1.0  1.0  1.0</span><br><span class="line"># 4  1.0  1.0  1.0</span><br><span class="line"># 5  1.0  1.0  1.0</span><br></pre></td></tr></table></figure>

<h5 id="join-axes-依照-axes-合并"><a href="#join-axes-依照-axes-合并" class="headerlink" title="join_axes (依照 axes 合并)"></a>join_axes (依照 axes 合并)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">#定义资料集</span><br><span class="line">df1 &#x3D; pd.DataFrame(np.ones((3,4))*0, columns&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;], index&#x3D;[1,2,3])</span><br><span class="line">df2 &#x3D; pd.DataFrame(np.ones((3,4))*1, columns&#x3D;[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;], index&#x3D;[2,3,4])</span><br><span class="line"></span><br><span class="line">#依照&#96;df1.index&#96;进行横向合并</span><br><span class="line">res &#x3D; pd.concat([df1, df2], axis&#x3D;1, join_axes&#x3D;[df1.index])</span><br><span class="line"></span><br><span class="line">#打印结果</span><br><span class="line">print(res)</span><br><span class="line">#     a    b    c    d    b    c    d    e</span><br><span class="line"># 1  0.0  0.0  0.0  0.0  NaN  NaN  NaN  NaN</span><br><span class="line"># 2  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0</span><br><span class="line"># 3  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0</span><br><span class="line"></span><br><span class="line">#移除join_axes，并打印结果</span><br><span class="line">res &#x3D; pd.concat([df1, df2], axis&#x3D;1)</span><br><span class="line">print(res)</span><br><span class="line">#     a    b    c    d    b    c    d    e</span><br><span class="line"># 1  0.0  0.0  0.0  0.0  NaN  NaN  NaN  NaN</span><br><span class="line"># 2  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0</span><br><span class="line"># 3  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0</span><br><span class="line"># 4  NaN  NaN  NaN  NaN  1.0  1.0  1.0  1.0</span><br></pre></td></tr></table></figure>

<h5 id="append-添加数据"><a href="#append-添加数据" class="headerlink" title="append (添加数据)"></a>append (添加数据)</h5><p><code>append</code>只有纵向合并，没有横向合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">#定义资料集</span><br><span class="line">df1 &#x3D; pd.DataFrame(np.ones((3,4))*0, columns&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])</span><br><span class="line">df2 &#x3D; pd.DataFrame(np.ones((3,4))*1, columns&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])</span><br><span class="line">df3 &#x3D; pd.DataFrame(np.ones((3,4))*1, columns&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])</span><br><span class="line">s1 &#x3D; pd.Series([1,2,3,4], index&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])</span><br><span class="line"></span><br><span class="line">#将df2合并到df1的下面，以及重置index，并打印出结果</span><br><span class="line">res &#x3D; df1.append(df2, ignore_index&#x3D;True)</span><br><span class="line">print(res)</span><br><span class="line">#     a    b    c    d</span><br><span class="line"># 0  0.0  0.0  0.0  0.0</span><br><span class="line"># 1  0.0  0.0  0.0  0.0</span><br><span class="line"># 2  0.0  0.0  0.0  0.0</span><br><span class="line"># 3  1.0  1.0  1.0  1.0</span><br><span class="line"># 4  1.0  1.0  1.0  1.0</span><br><span class="line"># 5  1.0  1.0  1.0  1.0</span><br><span class="line"></span><br><span class="line">#合并多个df，将df2与df3合并至df1的下面，以及重置index，并打印出结果</span><br><span class="line">res &#x3D; df1.append([df2, df3], ignore_index&#x3D;True)</span><br><span class="line">print(res)</span><br><span class="line">#     a    b    c    d</span><br><span class="line"># 0  0.0  0.0  0.0  0.0</span><br><span class="line"># 1  0.0  0.0  0.0  0.0</span><br><span class="line"># 2  0.0  0.0  0.0  0.0</span><br><span class="line"># 3  1.0  1.0  1.0  1.0</span><br><span class="line"># 4  1.0  1.0  1.0  1.0</span><br><span class="line"># 5  1.0  1.0  1.0  1.0</span><br><span class="line"># 6  1.0  1.0  1.0  1.0</span><br><span class="line"># 7  1.0  1.0  1.0  1.0</span><br><span class="line"># 8  1.0  1.0  1.0  1.0</span><br><span class="line"></span><br><span class="line">#合并series，将s1合并至df1，以及重置index，并打印出结果</span><br><span class="line">res &#x3D; df1.append(s1, ignore_index&#x3D;True)</span><br><span class="line">print(res)</span><br><span class="line">#     a    b    c    d</span><br><span class="line"># 0  0.0  0.0  0.0  0.0</span><br><span class="line"># 1  0.0  0.0  0.0  0.0</span><br><span class="line"># 2  0.0  0.0  0.0  0.0</span><br><span class="line"># 3  1.0  2.0  3.0  4.0</span><br></pre></td></tr></table></figure>





<h4 id="七：Pandas-合并-merge"><a href="#七：Pandas-合并-merge" class="headerlink" title="七：Pandas 合并 merge"></a>七：Pandas 合并 merge</h4><p>学习资料:</p>
<ul>
<li><a href="https://github.com/MorvanZhou/tutorials/blob/master/numpy%26pandas/17_merge.py" target="_blank" rel="noopener">相关代码</a></li>
</ul>
<h5 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h5><p><code>pandas</code>中的<code>merge</code>和<code>concat</code>类似,但主要是用于<strong>两组有key column的数据</strong>,统一索引的数据. 通常也被用在Database的处理当中.</p>
<h5 id="依据一组key合并"><a href="#依据一组key合并" class="headerlink" title="依据一组key合并"></a>依据一组key合并</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">#定义资料集并打印出</span><br><span class="line">left &#x3D; pd.DataFrame(&#123;&#39;key&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;, &#39;K3&#39;],</span><br><span class="line">                             &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],</span><br><span class="line">                             &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]&#125;)</span><br><span class="line">right &#x3D; pd.DataFrame(&#123;&#39;key&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;, &#39;K3&#39;],</span><br><span class="line">                              &#39;C&#39;: [&#39;C0&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;],</span><br><span class="line">                              &#39;D&#39;: [&#39;D0&#39;, &#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;]&#125;)</span><br><span class="line"></span><br><span class="line">print(left)</span><br><span class="line">#    A   B key</span><br><span class="line"># 0  A0  B0  K0</span><br><span class="line"># 1  A1  B1  K1</span><br><span class="line"># 2  A2  B2  K2</span><br><span class="line"># 3  A3  B3  K3</span><br><span class="line"></span><br><span class="line">print(right)</span><br><span class="line">#    C   D key</span><br><span class="line"># 0  C0  D0  K0</span><br><span class="line"># 1  C1  D1  K1</span><br><span class="line"># 2  C2  D2  K2</span><br><span class="line"># 3  C3  D3  K3</span><br><span class="line"></span><br><span class="line">#依据key column合并，并打印出</span><br><span class="line">res &#x3D; pd.merge(left, right, on&#x3D;&#39;key&#39;)</span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line">     A   B key   C   D</span><br><span class="line"># 0  A0  B0  K0  C0  D0</span><br><span class="line"># 1  A1  B1  K1  C1  D1</span><br><span class="line"># 2  A2  B2  K2  C2  D2</span><br><span class="line"># 3  A3  B3  K3  C3  D3</span><br></pre></td></tr></table></figure>



<h5 id="依据两组key合并"><a href="#依据两组key合并" class="headerlink" title="依据两组key合并"></a>依据两组key合并</h5><p>合并时有4种方法<code>how = [&#39;left&#39;, &#39;right&#39;, &#39;outer&#39;, &#39;inner&#39;]</code>，预设值<code>how=&#39;inner&#39;</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">#定义资料集并打印出</span><br><span class="line">left &#x3D; pd.DataFrame(&#123;&#39;key1&#39;: [&#39;K0&#39;, &#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;],</span><br><span class="line">                      &#39;key2&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K0&#39;, &#39;K1&#39;],</span><br><span class="line">                      &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],</span><br><span class="line">                      &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]&#125;)</span><br><span class="line">right &#x3D; pd.DataFrame(&#123;&#39;key1&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K1&#39;, &#39;K2&#39;],</span><br><span class="line">                       &#39;key2&#39;: [&#39;K0&#39;, &#39;K0&#39;, &#39;K0&#39;, &#39;K0&#39;],</span><br><span class="line">                       &#39;C&#39;: [&#39;C0&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;],</span><br><span class="line">                       &#39;D&#39;: [&#39;D0&#39;, &#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;]&#125;)</span><br><span class="line"></span><br><span class="line">print(left)</span><br><span class="line">#    A   B key1 key2</span><br><span class="line"># 0  A0  B0   K0   K0</span><br><span class="line"># 1  A1  B1   K0   K1</span><br><span class="line"># 2  A2  B2   K1   K0</span><br><span class="line"># 3  A3  B3   K2   K1</span><br><span class="line"></span><br><span class="line">print(right)</span><br><span class="line">#    C   D key1 key2</span><br><span class="line"># 0  C0  D0   K0   K0</span><br><span class="line"># 1  C1  D1   K1   K0</span><br><span class="line"># 2  C2  D2   K1   K0</span><br><span class="line"># 3  C3  D3   K2   K0</span><br><span class="line"></span><br><span class="line">#依据key1与key2 columns进行合并，并打印出四种结果[&#39;left&#39;, &#39;right&#39;, &#39;outer&#39;, &#39;inner&#39;]</span><br><span class="line">res &#x3D; pd.merge(left, right, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;], how&#x3D;&#39;inner&#39;)</span><br><span class="line">print(res)</span><br><span class="line">#    A   B key1 key2   C   D</span><br><span class="line"># 0  A0  B0   K0   K0  C0  D0</span><br><span class="line"># 1  A2  B2   K1   K0  C1  D1</span><br><span class="line"># 2  A2  B2   K1   K0  C2  D2</span><br><span class="line"></span><br><span class="line">res &#x3D; pd.merge(left, right, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;], how&#x3D;&#39;outer&#39;)</span><br><span class="line">print(res)</span><br><span class="line">#     A    B key1 key2    C    D</span><br><span class="line"># 0   A0   B0   K0   K0   C0   D0</span><br><span class="line"># 1   A1   B1   K0   K1  NaN  NaN</span><br><span class="line"># 2   A2   B2   K1   K0   C1   D1</span><br><span class="line"># 3   A2   B2   K1   K0   C2   D2</span><br><span class="line"># 4   A3   B3   K2   K1  NaN  NaN</span><br><span class="line"># 5  NaN  NaN   K2   K0   C3   D3</span><br><span class="line"></span><br><span class="line">res &#x3D; pd.merge(left, right, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;], how&#x3D;&#39;left&#39;)</span><br><span class="line">print(res)</span><br><span class="line">#    A   B key1 key2    C    D</span><br><span class="line"># 0  A0  B0   K0   K0   C0   D0</span><br><span class="line"># 1  A1  B1   K0   K1  NaN  NaN</span><br><span class="line"># 2  A2  B2   K1   K0   C1   D1</span><br><span class="line"># 3  A2  B2   K1   K0   C2   D2</span><br><span class="line"># 4  A3  B3   K2   K1  NaN  NaN</span><br><span class="line"></span><br><span class="line">res &#x3D; pd.merge(left, right, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;], how&#x3D;&#39;right&#39;)</span><br><span class="line">print(res)</span><br><span class="line">#     A    B key1 key2   C   D</span><br><span class="line"># 0   A0   B0   K0   K0  C0  D0</span><br><span class="line"># 1   A2   B2   K1   K0  C1  D1</span><br><span class="line"># 2   A2   B2   K1   K0  C2  D2</span><br><span class="line"># 3  NaN  NaN   K2   K0  C3  D3</span><br></pre></td></tr></table></figure>

<h5 id="Indicator"><a href="#Indicator" class="headerlink" title="Indicator"></a>Indicator</h5><p><code>indicator=True</code>会将合并的记录放在新的一列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">#定义资料集并打印出</span><br><span class="line">df1 &#x3D; pd.DataFrame(&#123;&#39;col1&#39;:[0,1], &#39;col_left&#39;:[&#39;a&#39;,&#39;b&#39;]&#125;)</span><br><span class="line">df2 &#x3D; pd.DataFrame(&#123;&#39;col1&#39;:[1,2,2],&#39;col_right&#39;:[2,2,2]&#125;)</span><br><span class="line"></span><br><span class="line">print(df1)</span><br><span class="line">#   col1 col_left</span><br><span class="line"># 0     0        a</span><br><span class="line"># 1     1        b</span><br><span class="line"></span><br><span class="line">print(df2)</span><br><span class="line">#   col1  col_right</span><br><span class="line"># 0     1          2</span><br><span class="line"># 1     2          2</span><br><span class="line"># 2     2          2</span><br><span class="line"></span><br><span class="line"># 依据col1进行合并，并启用indicator&#x3D;True，最后打印出</span><br><span class="line">res &#x3D; pd.merge(df1, df2, on&#x3D;&#39;col1&#39;, how&#x3D;&#39;outer&#39;, indicator&#x3D;True)</span><br><span class="line">print(res)</span><br><span class="line">#   col1 col_left  col_right      _merge</span><br><span class="line"># 0   0.0        a        NaN   left_only</span><br><span class="line"># 1   1.0        b        2.0        both</span><br><span class="line"># 2   2.0      NaN        2.0  right_only</span><br><span class="line"># 3   2.0      NaN        2.0  right_only</span><br><span class="line"></span><br><span class="line"># 自定indicator column的名称，并打印出</span><br><span class="line">res &#x3D; pd.merge(df1, df2, on&#x3D;&#39;col1&#39;, how&#x3D;&#39;outer&#39;, indicator&#x3D;&#39;indicator_column&#39;)</span><br><span class="line">print(res)</span><br><span class="line">#   col1 col_left  col_right indicator_column</span><br><span class="line"># 0   0.0        a        NaN        left_only</span><br><span class="line"># 1   1.0        b        2.0             both</span><br><span class="line"># 2   2.0      NaN        2.0       right_only</span><br><span class="line"># 3   2.0      NaN        2.0       right_only</span><br></pre></td></tr></table></figure>

<h5 id="依据index合并"><a href="#依据index合并" class="headerlink" title="依据index合并"></a>依据index合并</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">#定义资料集并打印出</span><br><span class="line">left &#x3D; pd.DataFrame(&#123;&#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;],</span><br><span class="line">                     &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;]&#125;,</span><br><span class="line">                     index&#x3D;[&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;])</span><br><span class="line">right &#x3D; pd.DataFrame(&#123;&#39;C&#39;: [&#39;C0&#39;, &#39;C2&#39;, &#39;C3&#39;],</span><br><span class="line">                      &#39;D&#39;: [&#39;D0&#39;, &#39;D2&#39;, &#39;D3&#39;]&#125;,</span><br><span class="line">                     index&#x3D;[&#39;K0&#39;, &#39;K2&#39;, &#39;K3&#39;])</span><br><span class="line"></span><br><span class="line">print(left)</span><br><span class="line">#     A   B</span><br><span class="line"># K0  A0  B0</span><br><span class="line"># K1  A1  B1</span><br><span class="line"># K2  A2  B2</span><br><span class="line"></span><br><span class="line">print(right)</span><br><span class="line">#     C   D</span><br><span class="line"># K0  C0  D0</span><br><span class="line"># K2  C2  D2</span><br><span class="line"># K3  C3  D3</span><br><span class="line"></span><br><span class="line">#依据左右资料集的index进行合并，how&#x3D;&#39;outer&#39;,并打印出</span><br><span class="line">res &#x3D; pd.merge(left, right, left_index&#x3D;True, right_index&#x3D;True, how&#x3D;&#39;outer&#39;)</span><br><span class="line">print(res)</span><br><span class="line">#      A    B    C    D</span><br><span class="line"># K0   A0   B0   C0   D0</span><br><span class="line"># K1   A1   B1  NaN  NaN</span><br><span class="line"># K2   A2   B2   C2   D2</span><br><span class="line"># K3  NaN  NaN   C3   D3</span><br><span class="line"></span><br><span class="line">#依据左右资料集的index进行合并，how&#x3D;&#39;inner&#39;,并打印出</span><br><span class="line">res &#x3D; pd.merge(left, right, left_index&#x3D;True, right_index&#x3D;True, how&#x3D;&#39;inner&#39;)</span><br><span class="line">print(res)</span><br><span class="line">#     A   B   C   D</span><br><span class="line"># K0  A0  B0  C0  D0</span><br><span class="line"># K2  A2  B2  C2  D2</span><br></pre></td></tr></table></figure>

<h5 id="解决overlapping的问题"><a href="#解决overlapping的问题" class="headerlink" title="解决overlapping的问题"></a>解决overlapping的问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">#定义资料集</span><br><span class="line">boys &#x3D; pd.DataFrame(&#123;&#39;k&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;], &#39;age&#39;: [1, 2, 3]&#125;)</span><br><span class="line">girls &#x3D; pd.DataFrame(&#123;&#39;k&#39;: [&#39;K0&#39;, &#39;K0&#39;, &#39;K3&#39;], &#39;age&#39;: [4, 5, 6]&#125;)</span><br><span class="line"></span><br><span class="line">#使用suffixes解决overlapping的问题</span><br><span class="line">res &#x3D; pd.merge(boys, girls, on&#x3D;&#39;k&#39;, suffixes&#x3D;[&#39;_boy&#39;, &#39;_girl&#39;], how&#x3D;&#39;inner&#39;)</span><br><span class="line">print(res)</span><br><span class="line">#    age_boy   k  age_girl</span><br><span class="line"># 0        1  K0         4</span><br><span class="line"># 1        1  K0         5</span><br></pre></td></tr></table></figure>






<h4 id="八：Pandas-plot-出图"><a href="#八：Pandas-plot-出图" class="headerlink" title="八：Pandas plot 出图"></a>八：Pandas plot 出图</h4><p>学习资料:</p>
<ul>
<li><a href="https://github.com/MorvanZhou/tutorials/blob/master/numpy%26pandas/18_plot.py" target="_blank" rel="noopener">相关代码</a></li>
</ul>
<p>这次我们讲如何将数据可视化. 首先<code>import</code>我们需要用到的模块，除了 pandas，我们也需要使用 numpy 生成一些数据，这节里使用的 matplotlib 仅仅是用来 show 图片的, 即 <code>plt.show()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure>

<p>今天我们主要是学习如何 plot data</p>
<h5 id="创建一个Series"><a href="#创建一个Series" class="headerlink" title="创建一个Series"></a>创建一个Series</h5><p>这是一个线性的数据，我们随机生成1000个数据，<code>Series</code> 默认的 <code>index</code> 就是从0开始的整数，但是这里我显式赋值以便让大家看的更清楚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 随机生成1000个数据</span><br><span class="line">data &#x3D; pd.Series(np.random.randn(1000),index&#x3D;np.arange(1000))</span><br><span class="line"> </span><br><span class="line"># 为了方便观看效果, 我们累加这个数据</span><br><span class="line">data.cumsum()</span><br><span class="line"></span><br><span class="line"># pandas 数据可以直接观看其可视化形式</span><br><span class="line">data.plot()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>就这么简单，熟悉 matplotlib 的朋友知道如果需要<code>plot</code>一个数据，我们可以使用 <code>plt.plot(x=, y=)</code>，把<code>x</code>,<code>y</code>的数据作为参数存进去，但是<code>data</code>本来就是一个数据，所以我们可以直接<code>plot</code>。 生成的结果就是下图：</p>
<p><a href="https://morvanzhou.github.io/static/results/np-pd/3-8-1.png" target="_blank" rel="noopener"><img src="/2019/11/24/python_numpy_pandas/3-8-1.png" alt="Pandas plot 出图"></a></p>
<h5 id="Dataframe-可视化"><a href="#Dataframe-可视化" class="headerlink" title="Dataframe 可视化"></a>Dataframe 可视化</h5><p>我们生成一个1000*4 的<code>DataFrame</code>，并对他们累加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data &#x3D; pd.DataFrame(</span><br><span class="line">    np.random.randn(1000,4),</span><br><span class="line">    index&#x3D;np.arange(1000),</span><br><span class="line">    columns&#x3D;list(&quot;ABCD&quot;)</span><br><span class="line">    )</span><br><span class="line">data.cumsum()</span><br><span class="line">data.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/np-pd/3-8-2.png" target="_blank" rel="noopener"><img src="/2019/11/24/python_numpy_pandas/3-8-2.png" alt="Pandas plot 出图"></a></p>
<p>这个就是我们刚刚生成的4个<code>column</code>的数据，因为有4组数据，所以4组数据会分别<code>plot</code>出来。<code>plot</code> 可以指定很多参数，具体的用法大家可以自己查一下<a href="http://pandas.pydata.org/pandas-docs/version/0.18.1/visualization.html" target="_blank" rel="noopener">这里</a></p>
<p>除了<code>plot</code>，我经常会用到还有<code>scatter</code>，这个会显示散点图，首先给大家说一下在 pandas 中有多少种方法</p>
<ul>
<li>bar</li>
<li>hist</li>
<li>box</li>
<li>kde</li>
<li>area</li>
<li>scatter</li>
<li>hexbin</li>
</ul>
<p>但是我们今天不会一一介绍，主要说一下 <code>plot</code> 和 <code>scatter</code>. 因为<code>scatter</code>只有<code>x</code>，<code>y</code>两个属性，我们我们就可以分别给<code>x</code>, <code>y</code>指定数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax &#x3D; data.plot.scatter(x&#x3D;&#39;A&#39;,y&#x3D;&#39;B&#39;,color&#x3D;&#39;DarkBlue&#39;,label&#x3D;&#39;Class1&#39;)</span><br></pre></td></tr></table></figure>

<p>然后我们在可以再画一个在同一个<code>ax</code>上面，选择不一样的数据列，不同的 <code>color</code> 和 <code>label</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将之下这个 data 画在上一个 ax 上面</span><br><span class="line">data.plot.scatter(x&#x3D;&#39;A&#39;,y&#x3D;&#39;C&#39;,color&#x3D;&#39;LightGreen&#39;,label&#x3D;&#39;Class2&#39;,ax&#x3D;ax)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>下面就是我<code>plot</code>出来的图片</p>
<p><a href="https://morvanzhou.github.io/static/results/np-pd/3-8-3.png" target="_blank" rel="noopener"><img src="/2019/11/24/python_numpy_pandas/3-8-3.png" alt="Pandas plot 出图"></a></p>
<p>这就是我们今天讲的两种呈现方式，一种是线性的方式，一种是散点图。</p>
<h3 id="为什么用-Numpy-还是慢-你用对了吗"><a href="#为什么用-Numpy-还是慢-你用对了吗" class="headerlink" title="为什么用 Numpy 还是慢, 你用对了吗?"></a>为什么用 Numpy 还是慢, 你用对了吗?</h3><p><strong>这原本是我写在知乎上的一篇文章, 觉得还是转到这个网站上作为一个教程比较好</strong></p>
<p>最近在写代码, 编一个 Python 模拟器, 做 simulation, 好不容易用传说中 Python 里速度最快的计算模块 “Numpy” 的写好了, 结果运行起来, 出奇的慢! 因为一次simulation要一个小时, 要不停测试, 所以自己受不了了.. 首先, 我的脑海中的问题, 渐渐浮现出来.</p>
<ul>
<li>我知道 Pandas 要比 Numpy 慢, 所以我尽量避免用 Pandas. 但是 Numpy (速度怪兽), 为什么还是这么慢?</li>
</ul>
<p>带有写代码洁癖的我好好给 google 了一番. 第一个出现在我眼前的就是这个文章, <a href="http://link.zhihu.com/?target=http%3A//ipython-books.github.io/featured-01/">Getting the Best Performance out of NumPy</a>. 所以我也将自己从这个文章中学到的诀窍分享给大家, 并补充一些内容.</p>
<h5 id="为什么用-Numpy"><a href="#为什么用-Numpy" class="headerlink" title="为什么用 Numpy?"></a>为什么用 Numpy?</h5><p>我们都知道, Python 是慢的, 简单来说, 因为 Python 执行你代码的时候会执行很多复杂的 “check” 功能, 比如当你赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b&#x3D;1; a&#x3D;b&#x2F;0.5</span><br></pre></td></tr></table></figure>

<p>这个运算看似简单, 但是在计算机内部, b 首先要从一个整数 <code>integer</code> 转换成浮点数 <code>float</code>, 才能进行后面的 <code>b/0.5</code>, 因为得到的要是一个小数. 还有很多其他的原因和详细说明 (比如 Python 对内存的调用) 在这里能够找到: <a href="http://link.zhihu.com/?target=https%3A//jakevdp.github.io/blog/2014/05/09/why-python-is-slow/">Why Python is Slow: Looking Under the Hood</a></p>
<p>提到 Numpy, 它就是一个 Python 的救星. 能把简单好用的 Python 和高性能的 C 语言合并在一起. 当你调用 Numpy 功能的时候, 他其实调用了很多 C 语言而不是纯 Python. 这就是为什么大家都爱用 Numpy 的原因.</p>
<h5 id="创建-Numpy-Array-的结构"><a href="#创建-Numpy-Array-的结构" class="headerlink" title="创建 Numpy Array 的结构"></a>创建 Numpy Array 的结构</h5><p>其实 Numpy 就是 C 的逻辑, 创建存储容器 “Array” 的时候是寻找内存上的一连串区域来存放, 而 Python 存放的时候则是不连续的区域, 这使得 Python 在索引这个容器里的数据时不是那么有效率. Numpy 只需要再这块固定的连续区域前后走走就能不费吹灰之力拿到数据. 下图是来自 <a href="http://link.zhihu.com/?target=https%3A//jakevdp.github.io/blog/2014/05/09/why-python-is-slow/">Why Python is Slow: Looking Under the Hood</a>, 他很好的解释了这一切.</p>
<p><a href="https://morvanzhou.github.io/static/results/np-pd/4-1-2.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/np-pd/4-1-2.png" alt="为什么用 Numpy 还是慢, 你用对了吗?"></a></p>
<p>在运用 Numpy 的时候, 我们通常不是用一个一维 Array 来存放数据, 而是用二维或者三维的块来存放 (说出了学机器学习的朋友们的心声~).</p>
<p><a href="https://morvanzhou.github.io/static/results/np-pd/4-1-3.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/np-pd/4-1-3.png" alt="为什么用 Numpy 还是慢, 你用对了吗?"></a></p>
<p>因为 Numpy 快速的矩阵相乘运算, 能将乘法运算分配到计算机中的多个核, 让运算并行. 这年头, 我们什么都想 <a href="https://morvanzhou.github.io/tutorials/python-basic/threading/" target="_blank" rel="noopener">多线程</a>/ <a href="https://morvanzhou.github.io/tutorials/python-basic/multiprocessing/" target="_blank" rel="noopener">多进程</a> (再次说出了机器学习同学们的心声~). 这也是 Numpy 为什么受人喜欢的一个原因. 这种并行运算大大加速了运算速度.</p>
<p>那么对于这种天天要用到的2D/3D Array, 我们通常都不会想着他是怎么来的. 因为按照我们正常人的想法, 这矩阵就是矩阵, 没什么深度的东西呀. 不过这可不然! 要不然我也不会写这篇分享了. 重点来了, 不管是1D/2D/3D 的 Array, 从根本上, 它都是一个 1D array!</p>
<p><a href="https://morvanzhou.github.io/static/results/np-pd/4-1-4.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/np-pd/4-1-4.png" alt="为什么用 Numpy 还是慢, 你用对了吗?"></a></p>
<p><a href="http://link.zhihu.com/?target=http%3A//ipython-books.github.io/featured-01/">这篇 Blog</a>的图显示. 在我们看来的 2D Array, 如果追溯到计算机内存里, 它其实是储存在一个连续空间上的. 而对于这个连续空间, 我们如果创建 Array 的方式不同, 在这个连续空间上的排列顺序也有不同. 这将影响之后所有的事情! 我们后面会用 Python 进行运算时间测试.</p>
<p>在 Numpy 中, 创建 2D Array 的默认方式是 “C-type” 以 row 为主在内存中排列, 而如果是 “Fortran” 的方式创建的, 就是以 column 为主在内存中排列.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">col_major &#x3D; np.zeros((10,10), order&#x3D;&#39;C&#39;)    # C-type</span><br><span class="line">row_major &#x3D; np.zeros((10,10), order&#x3D;&#39;F&#39;)    # Fortran</span><br></pre></td></tr></table></figure>



<h5 id="在-Axis-上的动作"><a href="#在-Axis-上的动作" class="headerlink" title="在 Axis 上的动作"></a>在 Axis 上的动作</h5><p>当你的计算中涉及合并矩阵, 不同形式的矩阵创建方式会给你不同的时间效果. 因为在 Numpy 中的矩阵合并等, 都是发生在一维空间里, ! 不是我们想象的二维空间中!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; np.zeros((200, 200), order&#x3D;&#39;C&#39;)</span><br><span class="line">b &#x3D; np.zeros((200, 200), order&#x3D;&#39;F&#39;)</span><br><span class="line">N &#x3D; 9999</span><br><span class="line"></span><br><span class="line">def f1(a):</span><br><span class="line">    for _ in range(N):</span><br><span class="line">        np.concatenate((a, a), axis&#x3D;0)</span><br><span class="line"></span><br><span class="line">def f2(b):</span><br><span class="line">    for _ in range(N):</span><br><span class="line">        np.concatenate((b, b), axis&#x3D;0)</span><br><span class="line"></span><br><span class="line">t0 &#x3D; time.time()</span><br><span class="line">f1(a)</span><br><span class="line">t1 &#x3D; time.time()</span><br><span class="line">f2(b)</span><br><span class="line">t2 &#x3D; time.time()</span><br><span class="line"></span><br><span class="line">print((t1-t0)&#x2F;N)     # 0.000040</span><br><span class="line">print((t2-t1)&#x2F;N)     # 0.000070</span><br></pre></td></tr></table></figure>

<p>从上面的那张图, 可以想到, row 为主的存储方式, 如果在 row 的方向上合并矩阵, 将会更快. 因为只要我们将思维放在 1D array 那, 直接再加一个 row 放在1D array 后面就好了, 所以在上面的测试中, <code>f1</code> 速度要更快. 但是在以 column 为主的系统中, 往 1D array 后面加 row 的规则变复杂了, 消耗的时间也变长. 如果以 <code>axis=1</code> 的方式合并, “F” 方式的 <code>f2</code> 将会比 “C” 方式的 <code>f1</code> 更好.</p>
<p>还有一个要提的事情, 为了图方便, 有时候我会直接使用 <code>np.stack</code> 来代替 <code>np.concatenate</code>, 因为这样可以少写一点代码, 不过使用上面的形式, 通过上面的测试发现是这样. 所以之后为了速度, 我推荐还是尽量使用 <code>np.concatenate</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.vstack((a,a))                # 0.000063</span><br><span class="line">np.concatenate((a,a), axis&#x3D;0)   # 0.000040</span><br></pre></td></tr></table></figure>

<p>或者有时候在某个 axis 上进行操作, 比如对上面用 “C-type” 创建的 <code>a</code> 矩阵选点:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">indices &#x3D; np.random.randint(0, 100, size&#x3D;10, dtype&#x3D;np.int32)</span><br><span class="line">a[indices, :]     # 0.000003</span><br><span class="line">a[:, indices]     # 0.000006</span><br></pre></td></tr></table></figure>

<p>因为 <code>a</code> 是用 row 为主的形式储存, 所以在 row 上面选数据要比在 column 上选快很多! 对于其他的 axis 的操作, 结果也类似. 所以你现在懂了吧, 看自己要在哪个 axis 上动的手脚多, 然后再创建合适于自己的矩阵形式 (“C-type”/”Fortran”).</p>
<h5 id="copy慢-view快"><a href="#copy慢-view快" class="headerlink" title="copy慢 view快"></a>copy慢 view快</h5><p>在 Numpy 中, 有两个很重要的概念, <code>copy</code> 和 <code>view</code>. <code>copy</code> 顾名思义, 会将数据 copy 出来存放在内存中另一个地方, 而 <code>view</code> 则是不 copy 数据, 直接取源数据的索引部分. 下图来自 <a href="http://link.zhihu.com/?target=https%3A//www.dataquest.io/blog/settingwithcopywarning/">Understanding SettingwithCopyWarning in pandas</a></p>
<p><a href="https://morvanzhou.github.io/static/results/np-pd/4-1-5.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/np-pd/4-1-5.png" alt="为什么用 Numpy 还是慢, 你用对了吗?"></a></p>
<p>上面说的是什么意思呢? 我们直接看代码.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; np.arange(1, 7).reshape((3,2))</span><br><span class="line">a_view &#x3D; a[:2]</span><br><span class="line">a_copy &#x3D; a[:2].copy()</span><br><span class="line"></span><br><span class="line">a_copy[1,1] &#x3D; 0</span><br><span class="line">print(a)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]]</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">a_view[1,1] &#x3D; 0</span><br><span class="line">print(a)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 0]</span><br><span class="line"> [5 6]]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>简单说, <code>a_view</code> 的东西全部都是 <code>a</code> 的东西, 动 <code>a_view</code> 的任何地方, <code>a</code> 都会被动到, 因为他们在内存中的位置是一模一样的, 本质上就是自己. 而 <code>a_copy</code> 则是将 <code>a</code> copy 了一份, 然后把 <code>a_copy</code> 放在内存中的另外的地方, 这样改变 <code>a_copy</code>, <code>a</code> 是不会被改变的.</p>
<p>那为什么要提这点呢? 因为 view 不会复制东西, 速度快! 我们来测试一下速度. 下面的例子中 <code>a*=2</code> 就是将这个 view 给赋值了, 和 <code>a[:] *= 2</code> 一个意思, 从头到尾没有创建新的东西. 而 <code>b = 2*b</code> 中, 我们将 <code>b</code> 赋值给另外一个新建的 <code>b</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; np.zeros((1000, 1000))</span><br><span class="line">b &#x3D; np.zeros((1000, 1000))</span><br><span class="line">N &#x3D; 9999</span><br><span class="line"></span><br><span class="line">def f1(a):</span><br><span class="line">    for _ in range(N):</span><br><span class="line">        a *&#x3D; 2           # same as a[:] *&#x3D; 2</span><br><span class="line"></span><br><span class="line">def f2(b):</span><br><span class="line">    for _ in range(N):</span><br><span class="line">        b &#x3D; 2*b</span><br><span class="line"></span><br><span class="line">print(&#39;%f&#39; % ((t1-t0)&#x2F;N))     # f1: 0.000837</span><br><span class="line">print(&#39;%f&#39; % ((t2-t1)&#x2F;N))     # f2: 0.001346</span><br></pre></td></tr></table></figure>

<p>对于 view 还有一点要提, 你是不是偶尔有时候要把一个矩阵展平, 用到 <code>np.flatten()</code> 或者 <code>np.ravel()</code>. 他俩是不同的! ravel 返回的是一个 view (谢谢知乎上评论的提醒, <a href="http://link.zhihu.com/?target=https%3A//docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html">官方说</a>如果用 ravel, 需要 copy 的时候才会被 copy , 我想这个时候可能是把 ravel 里面 order 转换的时候, 如 ‘C-type’ -&gt; ‘Fortran’), 而 flatten 返回的总是一个 copy. 现在你知道谁在拖你的后腿了吧! 下面的测试证明, 相比于 flatten, ravel 是神速.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def f1(a):</span><br><span class="line">    for _ in range(N):</span><br><span class="line">        a.flatten()</span><br><span class="line"></span><br><span class="line">def f2(b):</span><br><span class="line">    for _ in range(N):</span><br><span class="line">        b.ravel()</span><br><span class="line"></span><br><span class="line">print(&#39;%f&#39; % ((t1-t0)&#x2F;N))    # 0.001059</span><br><span class="line">print(&#39;%f&#39; % ((t2-t1)&#x2F;N))    # 0.000000</span><br></pre></td></tr></table></figure>

<h5 id="选择数据"><a href="#选择数据" class="headerlink" title="选择数据"></a>选择数据</h5><p>选择数据的时候, 我们常会用到 view 或者 copy 的形式. 我们知道了, 如果能用到 view 的, 我们就尽量用 view, 避免 copy 数据. 那什么时候会是 view 呢? 下面举例的都是 view 的方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a_view1 &#x3D; a[1:2, 3:6]    # 切片 slice</span><br><span class="line">a_view2 &#x3D; a[:100]        # 同上</span><br><span class="line">a_view3 &#x3D; a[::2]         # 跳步</span><br><span class="line">a_view4 &#x3D; a.ravel()      # 上面提到了</span><br><span class="line">...                      # 我只能想到这些, 如果还有请大家在评论里提出</span><br></pre></td></tr></table></figure>

<p>那哪些操作我们又会变成 copy 呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a_copy1 &#x3D; a[[1,4,6], [2,4,6]]   # 用 index 选</span><br><span class="line">a_copy2 &#x3D; a[[True, True], [False, True]]  # 用 mask</span><br><span class="line">a_copy3 &#x3D; a[[1,2], :]        # 虽然 1,2 的确连在一起了, 但是他们确实是 copy</span><br><span class="line">a_copy4 &#x3D; a[a[1,:] !&#x3D; 0, :]  # fancy indexing</span><br><span class="line">a_copy5 &#x3D; a[np.isnan(a), :]  # fancy indexing</span><br><span class="line">...                          # 我只能想到这些, 如果还有请大家在评论里提出</span><br></pre></td></tr></table></figure>

<p>Numpy 给了我们很多很自由的方式选择数据, 这些虽然都很方便, 但是如果你可以尽量避免这些操作, 你的速度可以飞起来.</p>
<p>在上面提到的 <a href="http://link.zhihu.com/?target=http%3A//ipython-books.github.io/featured-01/">blog</a> 里面, 他提到了, 如果你还是喜欢这种 fancy indexing 的形式, 我们也是可以对它加点速的. 那个 blog 中指出了两种方法</p>
<p>1.使用 <code>np.take()</code>, 替代用 index 选数据的方法.</p>
<p>上面提到了如果用index 来选数据, 像 <code>a_copy1 = a[[1,4,6], [2,4,6]]</code>, 用 take 在大部分情况中会比这样的 <code>a_copy1</code> 要快.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; np.random.rand(1000000, 10)</span><br><span class="line">N &#x3D; 99</span><br><span class="line">indices &#x3D; np.random.randint(0, 1000000, size&#x3D;10000)</span><br><span class="line"></span><br><span class="line">def f1(a):</span><br><span class="line">    for _ in range(N):</span><br><span class="line">        _ &#x3D; np.take(a, indices, axis&#x3D;0)</span><br><span class="line"></span><br><span class="line">def f2(b):</span><br><span class="line">    for _ in range(N):</span><br><span class="line">        _ &#x3D; b[indices]</span><br><span class="line"></span><br><span class="line">print(&#39;%f&#39; % ((t1-t0)&#x2F;N))    # 0.000393</span><br><span class="line">print(&#39;%f&#39; % ((t2-t1)&#x2F;N))    # 0.000569</span><br></pre></td></tr></table></figure>

<p>2.使用 <code>np.compress()</code>, 替代用 mask 选数据的方法.</p>
<p>上面的 <code>a_copy2 = a[[True, True], [False, True]]</code> 这种就是用 TRUE, FALSE 来选择数据的. 测试如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mask &#x3D; a[:, 0] &lt; 0.5</span><br><span class="line">def f1(a):</span><br><span class="line">    for _ in range(N):</span><br><span class="line">        _ &#x3D; np.compress(mask, a, axis&#x3D;0)</span><br><span class="line"></span><br><span class="line">def f2(b):</span><br><span class="line">    for _ in range(N):</span><br><span class="line">        _ &#x3D; b[mask]</span><br><span class="line"></span><br><span class="line">print(&#39;%f&#39; % ((t1-t0)&#x2F;N))    # 0.028109</span><br><span class="line">print(&#39;%f&#39; % ((t2-t1)&#x2F;N))    # 0.031013</span><br></pre></td></tr></table></figure>



<h5 id="非常有用的-out-参数"><a href="#非常有用的-out-参数" class="headerlink" title="非常有用的 out 参数"></a>非常有用的 out 参数</h5><p>不深入了解 numpy 的朋友, 应该会直接忽略很多功能中的这个 out 参数 (之前我从来没用过). 不过当我深入了解了以后, 发现他非常有用! 比如下面两个其实在功能上是没差的, 不过运算时间上有差, 我觉得可能是 <code>a=a+1</code> 要先转换成 <code>np.add()</code> 这种形式再运算, 所以前者要用更久一点的时间.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; a + 1         # 0.035230</span><br><span class="line">a &#x3D; np.add(a, 1)  # 0.032738</span><br></pre></td></tr></table></figure>

<p>如果是上面那样, 我们就会触发之前提到的 copy 原则, 这两个被赋值的 a, 都是原来 a 的一个 copy, 并不是 a 的 view. 但是在功能里面有一个 out 参数, 让我们不必要重新创建一个 a. 所以下面两个是一样的功能, 都不会创建另一个 copy. 不过可能是上面提到的那个原因, 这里的运算时间也有差.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a +&#x3D; 1                 # 0.011219</span><br><span class="line">np.add(a, 1, out&#x3D;a)    # 0.008843</span><br></pre></td></tr></table></figure>

<p>带有 out 的 numpy 功能都在这里:<a href="http://link.zhihu.com/?target=https%3A//docs.scipy.org/doc/numpy/reference/ufuncs.html%23available-ufuncs">Universal functions</a>. 所以只要是已经存在了一个 placeholder (比如 a), 我们就没有必要去再创建一个, 用 out 方便又有效.</p>
<h5 id="给数据一个名字"><a href="#给数据一个名字" class="headerlink" title="给数据一个名字"></a>给数据一个名字</h5><p>我喜欢用 pandas, 因为 pandas 能让你给数据命名, 用名字来做 index. 在数据类型很多的时候, 名字总是比 index 好记太多了, 也好用太多了. 但是 pandas 的确比 numpy 慢. 好在我们还是有途径可以实现用名字来索引. 这就是 structured array. 下面 a/b 的结构是一样的, 只是一个是 numpy 一个是 pandas.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; np.zeros(3, dtype&#x3D;[(&#39;foo&#39;, np.int32), (&#39;bar&#39;, np.float16)])</span><br><span class="line">b &#x3D; pd.DataFrame(np.zeros((3, 2), dtype&#x3D;np.int32), columns&#x3D;[&#39;foo&#39;, &#39;bar&#39;])</span><br><span class="line">b[&#39;bar&#39;] &#x3D; b[&#39;bar&#39;].astype(np.float16)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># a</span><br><span class="line">array([(0,  0.), (0,  0.), (0,  0.)],</span><br><span class="line">      dtype&#x3D;[(&#39;foo&#39;, &#39;&lt;i4&#39;), (&#39;bar&#39;, &#39;&lt;f2&#39;)])</span><br><span class="line"></span><br><span class="line"># b</span><br><span class="line">   foo  bar</span><br><span class="line">0    0  0.0</span><br><span class="line">1    0  0.0</span><br><span class="line">2    0  0.0</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def f1(a):</span><br><span class="line">    for _ in range(N):</span><br><span class="line">        a[&#39;bar&#39;] *&#x3D; a[&#39;foo&#39;]</span><br><span class="line"></span><br><span class="line">def f2(b):</span><br><span class="line">    for _ in range(N):</span><br><span class="line">        b[&#39;bar&#39;] *&#x3D; b[&#39;foo&#39;]</span><br><span class="line"></span><br><span class="line">print(&#39;%f&#39; % ((t1-t0)&#x2F;N))    # 0.000003</span><br><span class="line">print(&#39;%f&#39; % ((t2-t1)&#x2F;N))    # 0.000508</span><br></pre></td></tr></table></figure>

<p>可以看出来, numpy 明显比 pandas 快很多. 如果需要使用到不同数据形式, numpy 也是可以胜任的, 并且在还保持了快速的计算速度. 至于 pandas 为什么比 numpy 慢, 因为 pandas data 里面还有很多七七八八的数据, 记录着这个 data 的种种其他的特征. 这里还有更全面的对比: <a href="http://link.zhihu.com/?target=http%3A//gouthamanbalaraman.com/blog/numpy-vs-pandas-comparison.html">Numpy Vs Pandas Performance Comparison</a></p>
<p>如果大家还有其他的小技巧或者是速度大比拼, 欢迎在下面讨论. (一切为了速度~)</p>
<p>最后, 如果你对机器学习感兴趣, <a href="https://morvanzhou.github.io/tutorials/machine-learning/" target="_blank" rel="noopener">这里</a>有很多厉害的短片形式机器学习方法介绍和很多机器学习的 Python 实践教程, 让你可以用业余时间秒懂机器学习.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" rel="tag"># python语言学习</a>
              <a href="/tags/numpy/" rel="tag"># numpy</a>
              <a href="/tags/pandas/" rel="tag"># pandas</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/11/24/python/" rel="prev" title="python_生信分析">
      <i class="fa fa-chevron-left"></i> python_生信分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/11/24/install_R_Packages/" rel="next" title="R包安装">
      R包安装 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#python-numpy-amp-pandas学习"><span class="nav-number">1.</span> <span class="nav-text">python_numpy &amp;pandas学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#numpy的学习"><span class="nav-number">1.0.1.</span> <span class="nav-text">numpy的学习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一：安装numpy-and-pandas"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">一：安装numpy and pandas</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二：-简单的矩阵"><span class="nav-number">1.0.1.2.</span> <span class="nav-text">二： 简单的矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三：继续创建array"><span class="nav-number">1.0.1.3.</span> <span class="nav-text">三：继续创建array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四：numpy基础运算形式"><span class="nav-number">1.0.1.4.</span> <span class="nav-text">四：numpy基础运算形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五：Numpy-基础运算2"><span class="nav-number">1.0.1.5.</span> <span class="nav-text">五：Numpy 基础运算2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#六：numpy-的几种基本运算"><span class="nav-number">1.0.1.6.</span> <span class="nav-text">六：numpy 的几种基本运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#七：Numpy-索引"><span class="nav-number">1.0.1.7.</span> <span class="nav-text">七：Numpy 索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#八：Numpy-array-合并"><span class="nav-number">1.0.1.8.</span> <span class="nav-text">八：Numpy array 合并</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#np-vstack"><span class="nav-number">1.0.1.8.1.</span> <span class="nav-text">np.vstack()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#np-hstack"><span class="nav-number">1.0.1.8.2.</span> <span class="nav-text">np.hstack()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#np-newaxis"><span class="nav-number">1.0.1.8.3.</span> <span class="nav-text">np.newaxis()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#np-concatenate"><span class="nav-number">1.0.1.8.4.</span> <span class="nav-text">np.concatenate()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#九：Numpy-array-分割"><span class="nav-number">1.0.1.9.</span> <span class="nav-text">九：Numpy array 分割</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建数据"><span class="nav-number">1.0.1.9.1.</span> <span class="nav-text">创建数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#纵向分割"><span class="nav-number">1.0.1.9.2.</span> <span class="nav-text">纵向分割</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#横向分割"><span class="nav-number">1.0.1.9.3.</span> <span class="nav-text">横向分割</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#错误的分割"><span class="nav-number">1.0.1.9.4.</span> <span class="nav-text">错误的分割</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#不等量的分割"><span class="nav-number">1.0.1.9.5.</span> <span class="nav-text">不等量的分割</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#其他的分割方式"><span class="nav-number">1.0.1.9.6.</span> <span class="nav-text">其他的分割方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十：Numpy-copy-amp-deep-copy"><span class="nav-number">1.0.1.10.</span> <span class="nav-text">十：Numpy copy &amp; deep copy</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#的赋值方式会带有关联性"><span class="nav-number">1.0.1.10.1.</span> <span class="nav-text">&#x3D; 的赋值方式会带有关联性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#copy-的赋值方式没有关联性-¶"><span class="nav-number">1.0.1.10.2.</span> <span class="nav-text">copy() 的赋值方式没有关联性 </span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Panda的学习"><span class="nav-number">1.0.2.</span> <span class="nav-text">Panda的学习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一：Pandas-基本介绍"><span class="nav-number">1.0.2.1.</span> <span class="nav-text">一：Pandas 基本介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Numpy-和-Pandas-有什么不同"><span class="nav-number">1.0.2.1.1.</span> <span class="nav-text">Numpy 和 Pandas 有什么不同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Series"><span class="nav-number">1.0.2.1.2.</span> <span class="nav-text">Series</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DataFrame"><span class="nav-number">1.0.2.1.3.</span> <span class="nav-text">DataFrame</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DataFrame-的一些简单运用"><span class="nav-number">1.0.2.1.4.</span> <span class="nav-text">DataFrame 的一些简单运用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二：Pandas-选择数据"><span class="nav-number">1.0.2.2.</span> <span class="nav-text">二：Pandas 选择数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#简单的筛选"><span class="nav-number">1.0.2.2.1.</span> <span class="nav-text">简单的筛选</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#根据标签-loc"><span class="nav-number">1.0.2.2.2.</span> <span class="nav-text">根据标签 loc</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#根据序列-iloc-–position"><span class="nav-number">1.0.2.2.3.</span> <span class="nav-text">根据序列 iloc –position</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#根据混合的这两种-ix"><span class="nav-number">1.0.2.2.4.</span> <span class="nav-text">根据混合的这两种 ix</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通过判断的筛选"><span class="nav-number">1.0.2.2.5.</span> <span class="nav-text">通过判断的筛选</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pandas-设置值"><span class="nav-number">1.0.2.3.</span> <span class="nav-text">Pandas 设置值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建数据-1"><span class="nav-number">1.0.2.3.1.</span> <span class="nav-text">创建数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#根据位置设置-loc-和-iloc"><span class="nav-number">1.0.2.3.2.</span> <span class="nav-text">根据位置设置 loc 和 iloc</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#根据条件设置"><span class="nav-number">1.0.2.3.3.</span> <span class="nav-text">根据条件设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#按行或列设置"><span class="nav-number">1.0.2.3.4.</span> <span class="nav-text">按行或列设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#添加数据-¶"><span class="nav-number">1.0.2.3.5.</span> <span class="nav-text">添加数据 </span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四：Pandas-处理丢失数据"><span class="nav-number">1.0.2.4.</span> <span class="nav-text">四：Pandas 处理丢失数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建含-NaN-的矩阵"><span class="nav-number">1.0.2.4.1.</span> <span class="nav-text">创建含 NaN 的矩阵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pd-dropna"><span class="nav-number">1.0.2.4.2.</span> <span class="nav-text">pd.dropna()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pd-fillna"><span class="nav-number">1.0.2.4.3.</span> <span class="nav-text">pd.fillna()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pd-isnull"><span class="nav-number">1.0.2.4.4.</span> <span class="nav-text">pd.isnull()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五：Pandas-导入导出"><span class="nav-number">1.0.2.5.</span> <span class="nav-text">五：Pandas 导入导出</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#要点"><span class="nav-number">1.0.2.5.1.</span> <span class="nav-text">要点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#读取csv"><span class="nav-number">1.0.2.5.2.</span> <span class="nav-text">读取csv</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#将资料存取成pickle"><span class="nav-number">1.0.2.5.3.</span> <span class="nav-text">将资料存取成pickle</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#六：Pandas-合并-concat—concatenating"><span class="nav-number">1.0.2.6.</span> <span class="nav-text">六：Pandas 合并 concat—concatenating</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#要点-1"><span class="nav-number">1.0.2.6.1.</span> <span class="nav-text">要点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#axis-合并方向"><span class="nav-number">1.0.2.6.2.</span> <span class="nav-text">axis (合并方向)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ignore-index-重置-index"><span class="nav-number">1.0.2.6.3.</span> <span class="nav-text">ignore_index (重置 index)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#join-合并方式"><span class="nav-number">1.0.2.6.4.</span> <span class="nav-text">join (合并方式)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#join-axes-依照-axes-合并"><span class="nav-number">1.0.2.6.5.</span> <span class="nav-text">join_axes (依照 axes 合并)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#append-添加数据"><span class="nav-number">1.0.2.6.6.</span> <span class="nav-text">append (添加数据)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#七：Pandas-合并-merge"><span class="nav-number">1.0.2.7.</span> <span class="nav-text">七：Pandas 合并 merge</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#要点-2"><span class="nav-number">1.0.2.7.1.</span> <span class="nav-text">要点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#依据一组key合并"><span class="nav-number">1.0.2.7.2.</span> <span class="nav-text">依据一组key合并</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#依据两组key合并"><span class="nav-number">1.0.2.7.3.</span> <span class="nav-text">依据两组key合并</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Indicator"><span class="nav-number">1.0.2.7.4.</span> <span class="nav-text">Indicator</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#依据index合并"><span class="nav-number">1.0.2.7.5.</span> <span class="nav-text">依据index合并</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解决overlapping的问题"><span class="nav-number">1.0.2.7.6.</span> <span class="nav-text">解决overlapping的问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#八：Pandas-plot-出图"><span class="nav-number">1.0.2.8.</span> <span class="nav-text">八：Pandas plot 出图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建一个Series"><span class="nav-number">1.0.2.8.1.</span> <span class="nav-text">创建一个Series</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Dataframe-可视化"><span class="nav-number">1.0.2.8.2.</span> <span class="nav-text">Dataframe 可视化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么用-Numpy-还是慢-你用对了吗"><span class="nav-number">1.0.3.</span> <span class="nav-text">为什么用 Numpy 还是慢, 你用对了吗?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么用-Numpy"><span class="nav-number">1.0.3.0.1.</span> <span class="nav-text">为什么用 Numpy?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建-Numpy-Array-的结构"><span class="nav-number">1.0.3.0.2.</span> <span class="nav-text">创建 Numpy Array 的结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在-Axis-上的动作"><span class="nav-number">1.0.3.0.3.</span> <span class="nav-text">在 Axis 上的动作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#copy慢-view快"><span class="nav-number">1.0.3.0.4.</span> <span class="nav-text">copy慢 view快</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#选择数据"><span class="nav-number">1.0.3.0.5.</span> <span class="nav-text">选择数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#非常有用的-out-参数"><span class="nav-number">1.0.3.0.6.</span> <span class="nav-text">非常有用的 out 参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#给数据一个名字"><span class="nav-number">1.0.3.0.7.</span> <span class="nav-text">给数据一个名字</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yuqiao chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">86</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">109</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuqiao chen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
